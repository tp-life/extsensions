{"version":3,"file":"dapp-interface.js","mappings":"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","sources":["webpack:///../../../node_modules/.pnpm/@sentry+webpack-plugin@1.20.0/node_modules/@sentry/webpack-plugin/src/sentry-webpack.module.js","webpack:///../../../node_modules/.pnpm/base-x@4.0.0/node_modules/base-x/src/index.js","webpack:///../../../node_modules/.pnpm/bs58@5.0.0/node_modules/bs58/index.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///../../../node_modules/.pnpm/@wallet-standard+wallet@1.0.1/node_modules/@wallet-standard/wallet/lib/esm/register.js","webpack:///../../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/native.js","webpack:///../../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/rng.js","webpack:///../../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/stringify.js","webpack:///../../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/v4.js","webpack:///../../../node_modules/.pnpm/tslib@2.6.0/node_modules/tslib/tslib.es6.mjs","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isFunction.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/arrRemove.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subscription.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/config.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/noop.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/NotificationFactories.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/errorContext.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subscriber.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/symbol/observable.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/identity.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Observable.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/pipe.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/symbol/iterator.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isPromise.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isIterable.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/lift.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/map.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/filter.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subject.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/share.js","webpack:///./shared/messaging/WindowMessageStream.ts","webpack:///./shared/messaging/messages/payloads/permissions/PermissionType.ts","webpack:///./shared/api-env.ts","webpack:///./shared/messaging/messages/payloads/BasePayload.ts","webpack:///../../../sdk/bcs/src/b58.ts","webpack:///../../../sdk/bcs/src/b64.ts","webpack:///../../../sdk/bcs/src/hex.ts","webpack:///../../../sdk/bcs/src/uleb.ts","webpack:///../../../sdk/bcs/src/reader.ts","webpack:///../../../sdk/bcs/src/utils.ts","webpack:///../../../sdk/bcs/src/writer.ts","webpack:///../../../sdk/bcs/src/bcs-type.ts","webpack:///../../../node_modules/.pnpm/superstruct@1.0.3/node_modules/superstruct/dist/index.mjs","webpack:///../../../sdk/bcs/src/legacy-registry.ts","webpack:///../../../sdk/bcs/src/bcs.ts","webpack:///../../../sdk/typescript/src/utils/sui-types.ts","webpack:///../../../sdk/typescript/src/bcs/type-tag-serializer.ts","webpack:///../../../sdk/typescript/src/bcs/index.ts","webpack:///../../../sdk/typescript/src/types/normalized.ts","webpack:///../../../sdk/typescript/src/types/common.ts","webpack:///../../../sdk/typescript/src/types/objects.ts","webpack:///../../../sdk/typescript/src/utils/index.ts","webpack:///../../../sdk/typescript/src/builder/Inputs.ts","webpack:///../../../sdk/typescript/src/builder/serializer.ts","webpack:///../../../sdk/typescript/src/builder/Transactions.ts","webpack:///../../../sdk/typescript/src/builder/TransactionBlock.ts","webpack:///../../../sdk/wallet-standard/src/chains.ts","webpack:///../../../node_modules/.pnpm/@wallet-standard+wallet@1.0.1/node_modules/@wallet-standard/wallet/lib/esm/util.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/EmptyError.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/empty.js","webpack:///./dapp-interface/utils.ts","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js","webpack:///../../../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/take.js","webpack:///./shared/messaging/messages/payloads/ErrorPayload.ts","webpack:///./dapp-interface/WalletStandardInterface.ts","webpack:///./shared/messaging/messages/Message.ts","webpack:///./dapp-interface/index.ts","webpack:///../../../node_modules/.pnpm/mitt@3.0.1/node_modules/mitt/dist/mitt.mjs","webpack:///./shared/messaging/messages/payloads/QredoConnect.ts","webpack:///./shared/messaging/messages/payloads/wallet-status-change/index.ts"],"sourcesContent":["var _global = (typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}); _global.SENTRY_RELEASE={id:\"24.1.2.0\"};\n      _global.SENTRY_RELEASES=_global.SENTRY_RELEASES || {};\n      _global.SENTRY_RELEASES[\"wallet@mysten-labs\"]={id:\"24.1.2.0\"};\n      ","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _RegisterWalletEvent_detail;\n/**\n * Register a {@link \"@wallet-standard/base\".Wallet} as a Standard Wallet with the app.\n *\n * This dispatches a {@link \"@wallet-standard/base\".WindowRegisterWalletEvent} to notify the app that the Wallet is\n * ready to be registered.\n *\n * This also adds a listener for {@link \"@wallet-standard/base\".WindowAppReadyEvent} to listen for a notification from\n * the app that the app is ready to register the Wallet.\n *\n * This combination of event dispatch and listener guarantees that the Wallet will be registered synchronously as soon\n * as the app is ready whether the Wallet loads before or after the app.\n *\n * @param wallet Wallet to register.\n *\n * @group Wallet\n */\nexport function registerWallet(wallet) {\n    const callback = ({ register }) => register(wallet);\n    try {\n        window.dispatchEvent(new RegisterWalletEvent(callback));\n    }\n    catch (error) {\n        console.error('wallet-standard:register-wallet event could not be dispatched\\n', error);\n    }\n    try {\n        window.addEventListener('wallet-standard:app-ready', ({ detail: api }) => callback(api));\n    }\n    catch (error) {\n        console.error('wallet-standard:app-ready event listener could not be added\\n', error);\n    }\n}\nclass RegisterWalletEvent extends Event {\n    constructor(callback) {\n        super('wallet-standard:register-wallet', {\n            bubbles: false,\n            cancelable: false,\n            composed: false,\n        });\n        _RegisterWalletEvent_detail.set(this, void 0);\n        __classPrivateFieldSet(this, _RegisterWalletEvent_detail, callback, \"f\");\n    }\n    get detail() {\n        return __classPrivateFieldGet(this, _RegisterWalletEvent_detail, \"f\");\n    }\n    get type() {\n        return 'wallet-standard:register-wallet';\n    }\n    /** @deprecated */\n    preventDefault() {\n        throw new Error('preventDefault cannot be called');\n    }\n    /** @deprecated */\n    stopImmediatePropagation() {\n        throw new Error('stopImmediatePropagation cannot be called');\n    }\n    /** @deprecated */\n    stopPropagation() {\n        throw new Error('stopPropagation cannot be called');\n    }\n}\n_RegisterWalletEvent_detail = new WeakMap();\n/**\n * @deprecated Use {@link registerWallet} instead.\n *\n * @group Deprecated\n */\nexport function DEPRECATED_registerWallet(wallet) {\n    var _a;\n    registerWallet(wallet);\n    try {\n        ((_a = window.navigator).wallets || (_a.wallets = [])).push(({ register }) => register(wallet));\n    }\n    catch (error) {\n        console.error('window.navigator.wallets could not be pushed\\n', error);\n    }\n}\n//# sourceMappingURL=register.js.map","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n        if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n        dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n        if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n        dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  function next() {\n    while (env.stack.length) {\n      var rec = env.stack.pop();\n      try {\n        var result = rec.dispose && rec.dispose.call(rec.value);\n        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n      }\n      catch (e) {\n          fail(e);\n      }\n    }\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n};\n","export var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });\n//# sourceMappingURL=isArrayLike.js.map","export function isFunction(value) {\n    return typeof value === 'function';\n}\n//# sourceMappingURL=isFunction.js.map","export function createErrorClass(createImpl) {\n    var _super = function (instance) {\n        Error.call(instance);\n        instance.stack = new Error().stack;\n    };\n    var ctorFunc = createImpl(_super);\n    ctorFunc.prototype = Object.create(Error.prototype);\n    ctorFunc.prototype.constructor = ctorFunc;\n    return ctorFunc;\n}\n//# sourceMappingURL=createErrorClass.js.map","import { createErrorClass } from './createErrorClass';\nexport var UnsubscriptionError = createErrorClass(function (_super) {\n    return function UnsubscriptionErrorImpl(errors) {\n        _super(this);\n        this.message = errors\n            ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return i + 1 + \") \" + err.toString(); }).join('\\n  ')\n            : '';\n        this.name = 'UnsubscriptionError';\n        this.errors = errors;\n    };\n});\n//# sourceMappingURL=UnsubscriptionError.js.map","export function arrRemove(arr, item) {\n    if (arr) {\n        var index = arr.indexOf(item);\n        0 <= index && arr.splice(index, 1);\n    }\n}\n//# sourceMappingURL=arrRemove.js.map","import { __read, __spreadArray, __values } from \"tslib\";\nimport { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { arrRemove } from './util/arrRemove';\nvar Subscription = (function () {\n    function Subscription(initialTeardown) {\n        this.initialTeardown = initialTeardown;\n        this.closed = false;\n        this._parentage = null;\n        this._finalizers = null;\n    }\n    Subscription.prototype.unsubscribe = function () {\n        var e_1, _a, e_2, _b;\n        var errors;\n        if (!this.closed) {\n            this.closed = true;\n            var _parentage = this._parentage;\n            if (_parentage) {\n                this._parentage = null;\n                if (Array.isArray(_parentage)) {\n                    try {\n                        for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {\n                            var parent_1 = _parentage_1_1.value;\n                            parent_1.remove(this);\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                }\n                else {\n                    _parentage.remove(this);\n                }\n            }\n            var initialFinalizer = this.initialTeardown;\n            if (isFunction(initialFinalizer)) {\n                try {\n                    initialFinalizer();\n                }\n                catch (e) {\n                    errors = e instanceof UnsubscriptionError ? e.errors : [e];\n                }\n            }\n            var _finalizers = this._finalizers;\n            if (_finalizers) {\n                this._finalizers = null;\n                try {\n                    for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {\n                        var finalizer = _finalizers_1_1.value;\n                        try {\n                            execFinalizer(finalizer);\n                        }\n                        catch (err) {\n                            errors = errors !== null && errors !== void 0 ? errors : [];\n                            if (err instanceof UnsubscriptionError) {\n                                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));\n                            }\n                            else {\n                                errors.push(err);\n                            }\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n            if (errors) {\n                throw new UnsubscriptionError(errors);\n            }\n        }\n    };\n    Subscription.prototype.add = function (teardown) {\n        var _a;\n        if (teardown && teardown !== this) {\n            if (this.closed) {\n                execFinalizer(teardown);\n            }\n            else {\n                if (teardown instanceof Subscription) {\n                    if (teardown.closed || teardown._hasParent(this)) {\n                        return;\n                    }\n                    teardown._addParent(this);\n                }\n                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);\n            }\n        }\n    };\n    Subscription.prototype._hasParent = function (parent) {\n        var _parentage = this._parentage;\n        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n    };\n    Subscription.prototype._addParent = function (parent) {\n        var _parentage = this._parentage;\n        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n    };\n    Subscription.prototype._removeParent = function (parent) {\n        var _parentage = this._parentage;\n        if (_parentage === parent) {\n            this._parentage = null;\n        }\n        else if (Array.isArray(_parentage)) {\n            arrRemove(_parentage, parent);\n        }\n    };\n    Subscription.prototype.remove = function (teardown) {\n        var _finalizers = this._finalizers;\n        _finalizers && arrRemove(_finalizers, teardown);\n        if (teardown instanceof Subscription) {\n            teardown._removeParent(this);\n        }\n    };\n    Subscription.EMPTY = (function () {\n        var empty = new Subscription();\n        empty.closed = true;\n        return empty;\n    })();\n    return Subscription;\n}());\nexport { Subscription };\nexport var EMPTY_SUBSCRIPTION = Subscription.EMPTY;\nexport function isSubscription(value) {\n    return (value instanceof Subscription ||\n        (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));\n}\nfunction execFinalizer(finalizer) {\n    if (isFunction(finalizer)) {\n        finalizer();\n    }\n    else {\n        finalizer.unsubscribe();\n    }\n}\n//# sourceMappingURL=Subscription.js.map","export var config = {\n    onUnhandledError: null,\n    onStoppedNotification: null,\n    Promise: undefined,\n    useDeprecatedSynchronousErrorHandling: false,\n    useDeprecatedNextContext: false,\n};\n//# sourceMappingURL=config.js.map","import { __read, __spreadArray } from \"tslib\";\nexport var timeoutProvider = {\n    setTimeout: function (handler, timeout) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var delegate = timeoutProvider.delegate;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {\n            return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));\n        }\n        return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));\n    },\n    clearTimeout: function (handle) {\n        var delegate = timeoutProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=timeoutProvider.js.map","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\nexport function reportUnhandledError(err) {\n    timeoutProvider.setTimeout(function () {\n        var onUnhandledError = config.onUnhandledError;\n        if (onUnhandledError) {\n            onUnhandledError(err);\n        }\n        else {\n            throw err;\n        }\n    });\n}\n//# sourceMappingURL=reportUnhandledError.js.map","export function noop() { }\n//# sourceMappingURL=noop.js.map","export var COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();\nexport function errorNotification(error) {\n    return createNotification('E', undefined, error);\n}\nexport function nextNotification(value) {\n    return createNotification('N', value, undefined);\n}\nexport function createNotification(kind, value, error) {\n    return {\n        kind: kind,\n        value: value,\n        error: error,\n    };\n}\n//# sourceMappingURL=NotificationFactories.js.map","import { config } from '../config';\nvar context = null;\nexport function errorContext(cb) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        var isRoot = !context;\n        if (isRoot) {\n            context = { errorThrown: false, error: null };\n        }\n        cb();\n        if (isRoot) {\n            var _a = context, errorThrown = _a.errorThrown, error = _a.error;\n            context = null;\n            if (errorThrown) {\n                throw error;\n            }\n        }\n    }\n    else {\n        cb();\n    }\n}\nexport function captureError(err) {\n    if (config.useDeprecatedSynchronousErrorHandling && context) {\n        context.errorThrown = true;\n        context.error = err;\n    }\n}\n//# sourceMappingURL=errorContext.js.map","import { __extends } from \"tslib\";\nimport { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    function Subscriber(destination) {\n        var _this = _super.call(this) || this;\n        _this.isStopped = false;\n        if (destination) {\n            _this.destination = destination;\n            if (isSubscription(destination)) {\n                destination.add(_this);\n            }\n        }\n        else {\n            _this.destination = EMPTY_OBSERVER;\n        }\n        return _this;\n    }\n    Subscriber.create = function (next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    };\n    Subscriber.prototype.next = function (value) {\n        if (this.isStopped) {\n            handleStoppedNotification(nextNotification(value), this);\n        }\n        else {\n            this._next(value);\n        }\n    };\n    Subscriber.prototype.error = function (err) {\n        if (this.isStopped) {\n            handleStoppedNotification(errorNotification(err), this);\n        }\n        else {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    Subscriber.prototype.complete = function () {\n        if (this.isStopped) {\n            handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n        }\n        else {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.isStopped = true;\n            _super.prototype.unsubscribe.call(this);\n            this.destination = null;\n        }\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        try {\n            this.destination.error(err);\n        }\n        finally {\n            this.unsubscribe();\n        }\n    };\n    Subscriber.prototype._complete = function () {\n        try {\n            this.destination.complete();\n        }\n        finally {\n            this.unsubscribe();\n        }\n    };\n    return Subscriber;\n}(Subscription));\nexport { Subscriber };\nvar _bind = Function.prototype.bind;\nfunction bind(fn, thisArg) {\n    return _bind.call(fn, thisArg);\n}\nvar ConsumerObserver = (function () {\n    function ConsumerObserver(partialObserver) {\n        this.partialObserver = partialObserver;\n    }\n    ConsumerObserver.prototype.next = function (value) {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.next) {\n            try {\n                partialObserver.next(value);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    };\n    ConsumerObserver.prototype.error = function (err) {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.error) {\n            try {\n                partialObserver.error(err);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n        else {\n            handleUnhandledError(err);\n        }\n    };\n    ConsumerObserver.prototype.complete = function () {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.complete) {\n            try {\n                partialObserver.complete();\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    };\n    return ConsumerObserver;\n}());\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(observerOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        var partialObserver;\n        if (isFunction(observerOrNext) || !observerOrNext) {\n            partialObserver = {\n                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),\n                error: error !== null && error !== void 0 ? error : undefined,\n                complete: complete !== null && complete !== void 0 ? complete : undefined,\n            };\n        }\n        else {\n            var context_1;\n            if (_this && config.useDeprecatedNextContext) {\n                context_1 = Object.create(observerOrNext);\n                context_1.unsubscribe = function () { return _this.unsubscribe(); };\n                partialObserver = {\n                    next: observerOrNext.next && bind(observerOrNext.next, context_1),\n                    error: observerOrNext.error && bind(observerOrNext.error, context_1),\n                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),\n                };\n            }\n            else {\n                partialObserver = observerOrNext;\n            }\n        }\n        _this.destination = new ConsumerObserver(partialObserver);\n        return _this;\n    }\n    return SafeSubscriber;\n}(Subscriber));\nexport { SafeSubscriber };\nfunction handleUnhandledError(error) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        captureError(error);\n    }\n    else {\n        reportUnhandledError(error);\n    }\n}\nfunction defaultErrorHandler(err) {\n    throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n    var onStoppedNotification = config.onStoppedNotification;\n    onStoppedNotification && timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });\n}\nexport var EMPTY_OBSERVER = {\n    closed: true,\n    next: noop,\n    error: defaultErrorHandler,\n    complete: noop,\n};\n//# sourceMappingURL=Subscriber.js.map","export var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();\n//# sourceMappingURL=observable.js.map","export function identity(x) {\n    return x;\n}\n//# sourceMappingURL=identity.js.map","import { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription } from './Subscription';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\nvar Observable = (function () {\n    function Observable(subscribe) {\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var _this = this;\n        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n        errorContext(function () {\n            var _a = _this, operator = _a.operator, source = _a.source;\n            subscriber.add(operator\n                ?\n                    operator.call(subscriber, source)\n                : source\n                    ?\n                        _this._subscribe(subscriber)\n                    :\n                        _this._trySubscribe(subscriber));\n        });\n        return subscriber;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.error(err);\n        }\n    };\n    Observable.prototype.forEach = function (next, promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var subscriber = new SafeSubscriber({\n                next: function (value) {\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscriber.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve,\n            });\n            _this.subscribe(subscriber);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        var _a;\n        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);\n    };\n    Observable.prototype[Symbol_observable] = function () {\n        return this;\n    };\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i] = arguments[_i];\n        }\n        return pipeFromArray(operations)(this);\n    };\n    Observable.prototype.toPromise = function (promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexport { Observable };\nfunction getPromiseCtor(promiseCtor) {\n    var _a;\n    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;\n}\nfunction isObserver(value) {\n    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\nfunction isSubscriber(value) {\n    return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n//# sourceMappingURL=Observable.js.map","import { identity } from './identity';\nexport function pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    return pipeFromArray(fns);\n}\nexport function pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n    };\n}\n//# sourceMappingURL=pipe.js.map","export function getSymbolIterator() {\n    if (typeof Symbol !== 'function' || !Symbol.iterator) {\n        return '@@iterator';\n    }\n    return Symbol.iterator;\n}\nexport var iterator = getSymbolIterator();\n//# sourceMappingURL=iterator.js.map","import { __asyncValues, __awaiter, __generator, __values } from \"tslib\";\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\nexport function innerFrom(input) {\n    if (input instanceof Observable) {\n        return input;\n    }\n    if (input != null) {\n        if (isInteropObservable(input)) {\n            return fromInteropObservable(input);\n        }\n        if (isArrayLike(input)) {\n            return fromArrayLike(input);\n        }\n        if (isPromise(input)) {\n            return fromPromise(input);\n        }\n        if (isAsyncIterable(input)) {\n            return fromAsyncIterable(input);\n        }\n        if (isIterable(input)) {\n            return fromIterable(input);\n        }\n        if (isReadableStreamLike(input)) {\n            return fromReadableStreamLike(input);\n        }\n    }\n    throw createInvalidObservableTypeError(input);\n}\nexport function fromInteropObservable(obj) {\n    return new Observable(function (subscriber) {\n        var obs = obj[Symbol_observable]();\n        if (isFunction(obs.subscribe)) {\n            return obs.subscribe(subscriber);\n        }\n        throw new TypeError('Provided object does not correctly implement Symbol.observable');\n    });\n}\nexport function fromArrayLike(array) {\n    return new Observable(function (subscriber) {\n        for (var i = 0; i < array.length && !subscriber.closed; i++) {\n            subscriber.next(array[i]);\n        }\n        subscriber.complete();\n    });\n}\nexport function fromPromise(promise) {\n    return new Observable(function (subscriber) {\n        promise\n            .then(function (value) {\n            if (!subscriber.closed) {\n                subscriber.next(value);\n                subscriber.complete();\n            }\n        }, function (err) { return subscriber.error(err); })\n            .then(null, reportUnhandledError);\n    });\n}\nexport function fromIterable(iterable) {\n    return new Observable(function (subscriber) {\n        var e_1, _a;\n        try {\n            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {\n                var value = iterable_1_1.value;\n                subscriber.next(value);\n                if (subscriber.closed) {\n                    return;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        subscriber.complete();\n    });\n}\nexport function fromAsyncIterable(asyncIterable) {\n    return new Observable(function (subscriber) {\n        process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });\n    });\n}\nexport function fromReadableStreamLike(readableStream) {\n    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\nfunction process(asyncIterable, subscriber) {\n    var asyncIterable_1, asyncIterable_1_1;\n    var e_2, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var value, e_2_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _b.trys.push([0, 5, 6, 11]);\n                    asyncIterable_1 = __asyncValues(asyncIterable);\n                    _b.label = 1;\n                case 1: return [4, asyncIterable_1.next()];\n                case 2:\n                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];\n                    value = asyncIterable_1_1.value;\n                    subscriber.next(value);\n                    if (subscriber.closed) {\n                        return [2];\n                    }\n                    _b.label = 3;\n                case 3: return [3, 1];\n                case 4: return [3, 11];\n                case 5:\n                    e_2_1 = _b.sent();\n                    e_2 = { error: e_2_1 };\n                    return [3, 11];\n                case 6:\n                    _b.trys.push([6, , 9, 10]);\n                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];\n                    return [4, _a.call(asyncIterable_1)];\n                case 7:\n                    _b.sent();\n                    _b.label = 8;\n                case 8: return [3, 10];\n                case 9:\n                    if (e_2) throw e_2.error;\n                    return [7];\n                case 10: return [7];\n                case 11:\n                    subscriber.complete();\n                    return [2];\n            }\n        });\n    });\n}\n//# sourceMappingURL=innerFrom.js.map","import { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\nexport function isInteropObservable(input) {\n    return isFunction(input[Symbol_observable]);\n}\n//# sourceMappingURL=isInteropObservable.js.map","import { isFunction } from \"./isFunction\";\nexport function isPromise(value) {\n    return isFunction(value === null || value === void 0 ? void 0 : value.then);\n}\n//# sourceMappingURL=isPromise.js.map","import { isFunction } from './isFunction';\nexport function isAsyncIterable(obj) {\n    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);\n}\n//# sourceMappingURL=isAsyncIterable.js.map","import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\nexport function isIterable(input) {\n    return isFunction(input === null || input === void 0 ? void 0 : input[Symbol_iterator]);\n}\n//# sourceMappingURL=isIterable.js.map","import { __asyncGenerator, __await, __generator } from \"tslib\";\nimport { isFunction } from './isFunction';\nexport function readableStreamLikeToAsyncGenerator(readableStream) {\n    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {\n        var reader, _a, value, done;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    reader = readableStream.getReader();\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                case 2:\n                    if (!true) return [3, 8];\n                    return [4, __await(reader.read())];\n                case 3:\n                    _a = _b.sent(), value = _a.value, done = _a.done;\n                    if (!done) return [3, 5];\n                    return [4, __await(void 0)];\n                case 4: return [2, _b.sent()];\n                case 5: return [4, __await(value)];\n                case 6: return [4, _b.sent()];\n                case 7:\n                    _b.sent();\n                    return [3, 2];\n                case 8: return [3, 10];\n                case 9:\n                    reader.releaseLock();\n                    return [7];\n                case 10: return [2];\n            }\n        });\n    });\n}\nexport function isReadableStreamLike(obj) {\n    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);\n}\n//# sourceMappingURL=isReadableStreamLike.js.map","export function createInvalidObservableTypeError(input) {\n    return new TypeError(\"You provided \" + (input !== null && typeof input === 'object' ? 'an invalid object' : \"'\" + input + \"'\") + \" where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.\");\n}\n//# sourceMappingURL=throwUnobservableError.js.map","import { isFunction } from './isFunction';\nexport function hasLift(source) {\n    return isFunction(source === null || source === void 0 ? void 0 : source.lift);\n}\nexport function operate(init) {\n    return function (source) {\n        if (hasLift(source)) {\n            return source.lift(function (liftedSource) {\n                try {\n                    return init(liftedSource, this);\n                }\n                catch (err) {\n                    this.error(err);\n                }\n            });\n        }\n        throw new TypeError('Unable to lift unknown Observable type');\n    };\n}\n//# sourceMappingURL=lift.js.map","import { __extends } from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {\n    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\nvar OperatorSubscriber = (function (_super) {\n    __extends(OperatorSubscriber, _super);\n    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {\n        var _this = _super.call(this, destination) || this;\n        _this.onFinalize = onFinalize;\n        _this.shouldUnsubscribe = shouldUnsubscribe;\n        _this._next = onNext\n            ? function (value) {\n                try {\n                    onNext(value);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n            }\n            : _super.prototype._next;\n        _this._error = onError\n            ? function (err) {\n                try {\n                    onError(err);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : _super.prototype._error;\n        _this._complete = onComplete\n            ? function () {\n                try {\n                    onComplete();\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : _super.prototype._complete;\n        return _this;\n    }\n    OperatorSubscriber.prototype.unsubscribe = function () {\n        var _a;\n        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n            var closed_1 = this.closed;\n            _super.prototype.unsubscribe.call(this);\n            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));\n        }\n    };\n    return OperatorSubscriber;\n}(Subscriber));\nexport { OperatorSubscriber };\n//# sourceMappingURL=OperatorSubscriber.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function map(project, thisArg) {\n    return operate(function (source, subscriber) {\n        var index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n            subscriber.next(project.call(thisArg, value, index++));\n        }));\n    });\n}\n//# sourceMappingURL=map.js.map","import { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\nexport function mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Infinity; }\n    if (isFunction(resultSelector)) {\n        return mergeMap(function (a, i) { return map(function (b, ii) { return resultSelector(a, b, i, ii); })(innerFrom(project(a, i))); }, concurrent);\n    }\n    else if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return operate(function (source, subscriber) { return mergeInternals(source, subscriber, project, concurrent); });\n}\n//# sourceMappingURL=mergeMap.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n    var buffer = [];\n    var active = 0;\n    var index = 0;\n    var isComplete = false;\n    var checkComplete = function () {\n        if (isComplete && !buffer.length && !active) {\n            subscriber.complete();\n        }\n    };\n    var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };\n    var doInnerSub = function (value) {\n        expand && subscriber.next(value);\n        active++;\n        var innerComplete = false;\n        innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function (innerValue) {\n            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n            if (expand) {\n                outerNext(innerValue);\n            }\n            else {\n                subscriber.next(innerValue);\n            }\n        }, function () {\n            innerComplete = true;\n        }, undefined, function () {\n            if (innerComplete) {\n                try {\n                    active--;\n                    var _loop_1 = function () {\n                        var bufferedValue = buffer.shift();\n                        if (innerSubScheduler) {\n                            executeSchedule(subscriber, innerSubScheduler, function () { return doInnerSub(bufferedValue); });\n                        }\n                        else {\n                            doInnerSub(bufferedValue);\n                        }\n                    };\n                    while (buffer.length && active < concurrent) {\n                        _loop_1();\n                    }\n                    checkComplete();\n                }\n                catch (err) {\n                    subscriber.error(err);\n                }\n            }\n        }));\n    };\n    source.subscribe(createOperatorSubscriber(subscriber, outerNext, function () {\n        isComplete = true;\n        checkComplete();\n    }));\n    return function () {\n        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n    };\n}\n//# sourceMappingURL=mergeInternals.js.map","import { __read, __spreadArray } from \"tslib\";\nimport { map } from \"../operators/map\";\nvar isArray = Array.isArray;\nfunction callOrApply(fn, args) {\n    return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);\n}\nexport function mapOneOrManyArgs(fn) {\n    return map(function (args) { return callOrApply(fn, args); });\n}\n//# sourceMappingURL=mapOneOrManyArgs.js.map","import { __read } from \"tslib\";\nimport { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nvar nodeEventEmitterMethods = ['addListener', 'removeListener'];\nvar eventTargetMethods = ['addEventListener', 'removeEventListener'];\nvar jqueryMethods = ['on', 'off'];\nexport function fromEvent(target, eventName, options, resultSelector) {\n    if (isFunction(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));\n    }\n    var _a = __read(isEventTarget(target)\n        ? eventTargetMethods.map(function (methodName) { return function (handler) { return target[methodName](eventName, handler, options); }; })\n        :\n            isNodeStyleEventEmitter(target)\n                ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n                : isJQueryStyleEventEmitter(target)\n                    ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n                    : [], 2), add = _a[0], remove = _a[1];\n    if (!add) {\n        if (isArrayLike(target)) {\n            return mergeMap(function (subTarget) { return fromEvent(subTarget, eventName, options); })(innerFrom(target));\n        }\n    }\n    if (!add) {\n        throw new TypeError('Invalid event target');\n    }\n    return new Observable(function (subscriber) {\n        var handler = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return subscriber.next(1 < args.length ? args : args[0]);\n        };\n        add(handler);\n        return function () { return remove(handler); };\n    });\n}\nfunction toCommonHandlerRegistry(target, eventName) {\n    return function (methodName) { return function (handler) { return target[methodName](eventName, handler); }; };\n}\nfunction isNodeStyleEventEmitter(target) {\n    return isFunction(target.addListener) && isFunction(target.removeListener);\n}\nfunction isJQueryStyleEventEmitter(target) {\n    return isFunction(target.on) && isFunction(target.off);\n}\nfunction isEventTarget(target) {\n    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n//# sourceMappingURL=fromEvent.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function filter(predicate, thisArg) {\n    return operate(function (source, subscriber) {\n        var index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));\n    });\n}\n//# sourceMappingURL=filter.js.map","import { createErrorClass } from './createErrorClass';\nexport var ObjectUnsubscribedError = createErrorClass(function (_super) {\n    return function ObjectUnsubscribedErrorImpl() {\n        _super(this);\n        this.name = 'ObjectUnsubscribedError';\n        this.message = 'object unsubscribed';\n    };\n});\n//# sourceMappingURL=ObjectUnsubscribedError.js.map","import { __extends, __values } from \"tslib\";\nimport { Observable } from './Observable';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        var _this = _super.call(this) || this;\n        _this.closed = false;\n        _this.currentObservers = null;\n        _this.observers = [];\n        _this.isStopped = false;\n        _this.hasError = false;\n        _this.thrownError = null;\n        return _this;\n    }\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype._throwIfClosed = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n    };\n    Subject.prototype.next = function (value) {\n        var _this = this;\n        errorContext(function () {\n            var e_1, _a;\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                if (!_this.currentObservers) {\n                    _this.currentObservers = Array.from(_this.observers);\n                }\n                try {\n                    for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {\n                        var observer = _c.value;\n                        observer.next(value);\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n        });\n    };\n    Subject.prototype.error = function (err) {\n        var _this = this;\n        errorContext(function () {\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                _this.hasError = _this.isStopped = true;\n                _this.thrownError = err;\n                var observers = _this.observers;\n                while (observers.length) {\n                    observers.shift().error(err);\n                }\n            }\n        });\n    };\n    Subject.prototype.complete = function () {\n        var _this = this;\n        errorContext(function () {\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                _this.isStopped = true;\n                var observers = _this.observers;\n                while (observers.length) {\n                    observers.shift().complete();\n                }\n            }\n        });\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = this.closed = true;\n        this.observers = this.currentObservers = null;\n    };\n    Object.defineProperty(Subject.prototype, \"observed\", {\n        get: function () {\n            var _a;\n            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Subject.prototype._trySubscribe = function (subscriber) {\n        this._throwIfClosed();\n        return _super.prototype._trySubscribe.call(this, subscriber);\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        this._throwIfClosed();\n        this._checkFinalizedStatuses(subscriber);\n        return this._innerSubscribe(subscriber);\n    };\n    Subject.prototype._innerSubscribe = function (subscriber) {\n        var _this = this;\n        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;\n        if (hasError || isStopped) {\n            return EMPTY_SUBSCRIPTION;\n        }\n        this.currentObservers = null;\n        observers.push(subscriber);\n        return new Subscription(function () {\n            _this.currentObservers = null;\n            arrRemove(observers, subscriber);\n        });\n    };\n    Subject.prototype._checkFinalizedStatuses = function (subscriber) {\n        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;\n        if (hasError) {\n            subscriber.error(thrownError);\n        }\n        else if (isStopped) {\n            subscriber.complete();\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable));\nexport { Subject };\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        var _this = _super.call(this) || this;\n        _this.destination = destination;\n        _this.source = source;\n        return _this;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var _a, _b;\n        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;\n    };\n    return AnonymousSubject;\n}(Subject));\nexport { AnonymousSubject };\n//# sourceMappingURL=Subject.js.map","import { __read, __spreadArray } from \"tslib\";\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { operate } from '../util/lift';\nexport function share(options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.connector, connector = _a === void 0 ? function () { return new Subject(); } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;\n    return function (wrapperSource) {\n        var connection;\n        var resetConnection;\n        var subject;\n        var refCount = 0;\n        var hasCompleted = false;\n        var hasErrored = false;\n        var cancelReset = function () {\n            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();\n            resetConnection = undefined;\n        };\n        var reset = function () {\n            cancelReset();\n            connection = subject = undefined;\n            hasCompleted = hasErrored = false;\n        };\n        var resetAndUnsubscribe = function () {\n            var conn = connection;\n            reset();\n            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();\n        };\n        return operate(function (source, subscriber) {\n            refCount++;\n            if (!hasErrored && !hasCompleted) {\n                cancelReset();\n            }\n            var dest = (subject = subject !== null && subject !== void 0 ? subject : connector());\n            subscriber.add(function () {\n                refCount--;\n                if (refCount === 0 && !hasErrored && !hasCompleted) {\n                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n                }\n            });\n            dest.subscribe(subscriber);\n            if (!connection &&\n                refCount > 0) {\n                connection = new SafeSubscriber({\n                    next: function (value) { return dest.next(value); },\n                    error: function (err) {\n                        hasErrored = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnError, err);\n                        dest.error(err);\n                    },\n                    complete: function () {\n                        hasCompleted = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnComplete);\n                        dest.complete();\n                    },\n                });\n                innerFrom(source).subscribe(connection);\n            }\n        })(wrapperSource);\n    };\n}\nfunction handleReset(reset, on) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    if (on === true) {\n        reset();\n        return;\n    }\n    if (on === false) {\n        return;\n    }\n    var onSubscriber = new SafeSubscriber({\n        next: function () {\n            onSubscriber.unsubscribe();\n            reset();\n        },\n    });\n    return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);\n}\n//# sourceMappingURL=share.js.map","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Message } from '_messages';\nimport { filter, fromEvent, map, share } from 'rxjs';\nimport type { Observable } from 'rxjs';\n\nexport type ClientType = 'sui_in-page' | 'sui_content-script';\n\ntype WindowMessage = {\n\ttarget: ClientType;\n\tpayload: Message;\n};\n\nexport class WindowMessageStream {\n\tpublic readonly messages: Observable<Message>;\n\tprivate _name: ClientType;\n\tprivate _target: ClientType;\n\n\tconstructor(name: ClientType, target: ClientType) {\n\t\tif (name === target) {\n\t\t\tthrow new Error('[WindowMessageStream] name and target must be different');\n\t\t}\n\t\tthis._name = name;\n\t\tthis._target = target;\n\t\tthis.messages = fromEvent<MessageEvent<WindowMessage>>(window, 'message').pipe(\n\t\t\tfilter((message) => message.source === window && message.data.target === this._name),\n\t\t\tmap((message) => message.data.payload),\n\t\t\tshare(),\n\t\t);\n\t}\n\n\tpublic send(payload: Message) {\n\t\tconst msg: WindowMessage = {\n\t\t\ttarget: this._target,\n\t\t\tpayload,\n\t\t};\n\t\twindow.postMessage(msg);\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport const ALL_PERMISSION_TYPES = ['viewAccount', 'suggestTransactions'] as const;\ntype AllPermissionsType = typeof ALL_PERMISSION_TYPES;\nexport type PermissionType = AllPermissionsType[number];\n\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nexport function isValidPermissionTypes(types: any): types is PermissionType[] {\n\treturn (\n\t\tArray.isArray(types) &&\n\t\t!!types.length &&\n\t\ttypes.every((aType) => ALL_PERMISSION_TYPES.includes(aType))\n\t);\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport enum API_ENV {\n\tmainnet = 'mainnet',\n\tdevNet = 'devNet',\n\ttestNet = 'testNet',\n\tlocal = 'local',\n\tcustomRPC = 'customRPC',\n}\n\nexport const networkNames: Record<API_ENV, string> = {\n\t[API_ENV.local]: 'Local',\n\t[API_ENV.testNet]: 'Testnet',\n\t[API_ENV.devNet]: 'Devnet',\n\t[API_ENV.mainnet]: 'Mainnet',\n\t[API_ENV.customRPC]: 'Custom RPC',\n};\n\nexport type NetworkEnvType =\n\t| { env: Exclude<API_ENV, API_ENV.customRPC>; customRpcUrl: null }\n\t| { env: API_ENV.customRPC; customRpcUrl: string };\n\nexport const ENV_TO_API: Record<API_ENV, string | null> = {\n\t[API_ENV.customRPC]: null,\n\t[API_ENV.local]: process.env.API_ENDPOINT_LOCAL_FULLNODE || '',\n\t[API_ENV.devNet]: process.env.API_ENDPOINT_DEV_NET_FULLNODE || '',\n\t[API_ENV.testNet]: process.env.API_ENDPOINT_TEST_NET_FULLNODE || '',\n\t[API_ENV.mainnet]: process.env.API_ENDPOINT_MAINNET_FULLNODE || '',\n};\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Payload } from './Payload';\n\nexport type PayloadType =\n\t| 'permission-request'\n\t| 'permission-response'\n\t| 'get-permission-requests'\n\t| 'get-account'\n\t| 'get-account-response'\n\t| 'has-permissions-request'\n\t| 'has-permissions-response'\n\t| 'acquire-permissions-request'\n\t| 'acquire-permissions-response'\n\t| 'execute-transaction-request'\n\t| 'execute-transaction-response'\n\t| 'sign-transaction-request'\n\t| 'sign-transaction-response'\n\t| 'get-transaction-requests'\n\t| 'get-transaction-requests-response'\n\t| 'transaction-request-response'\n\t| 'update-active-origin'\n\t| 'disconnect-app'\n\t| 'done'\n\t| 'keyring'\n\t| 'wallet-status-changed'\n\t| 'get-features'\n\t| 'features-response'\n\t| 'get-network'\n\t| 'set-network'\n\t| 'sign-message-request'\n\t| 'qredo-connect'\n\t| 'method-payload';\n\nexport interface BasePayload {\n\ttype: PayloadType;\n}\n\nexport function isBasePayload(payload: Payload): payload is BasePayload {\n\treturn 'type' in payload && typeof payload.type !== 'undefined';\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport bs58 from 'bs58';\n\nexport const toB58 = (buffer: Uint8Array) => bs58.encode(buffer);\nexport const fromB58 = (str: string) => bs58.decode(str);\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/*\\\n|*|  Base64 / binary data / UTF-8 strings utilities\n|*|  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding\n\\*/\n\n/* Array of bytes to Base64 string decoding */\n\nfunction b64ToUint6(nChr: number) {\n\treturn nChr > 64 && nChr < 91\n\t\t? nChr - 65\n\t\t: nChr > 96 && nChr < 123\n\t\t? nChr - 71\n\t\t: nChr > 47 && nChr < 58\n\t\t? nChr + 4\n\t\t: nChr === 43\n\t\t? 62\n\t\t: nChr === 47\n\t\t? 63\n\t\t: 0;\n}\n\nexport function fromB64(sBase64: string, nBlocksSize?: number): Uint8Array {\n\tvar sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, ''),\n\t\tnInLen = sB64Enc.length,\n\t\tnOutLen = nBlocksSize\n\t\t\t? Math.ceil(((nInLen * 3 + 1) >> 2) / nBlocksSize) * nBlocksSize\n\t\t\t: (nInLen * 3 + 1) >> 2,\n\t\ttaBytes = new Uint8Array(nOutLen);\n\n\tfor (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n\t\tnMod4 = nInIdx & 3;\n\t\tnUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << (6 * (3 - nMod4));\n\t\tif (nMod4 === 3 || nInLen - nInIdx === 1) {\n\t\t\tfor (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n\t\t\t\ttaBytes[nOutIdx] = (nUint24 >>> ((16 >>> nMod3) & 24)) & 255;\n\t\t\t}\n\t\t\tnUint24 = 0;\n\t\t}\n\t}\n\n\treturn taBytes;\n}\n\n/* Base64 string to array encoding */\n\nfunction uint6ToB64(nUint6: number) {\n\treturn nUint6 < 26\n\t\t? nUint6 + 65\n\t\t: nUint6 < 52\n\t\t? nUint6 + 71\n\t\t: nUint6 < 62\n\t\t? nUint6 - 4\n\t\t: nUint6 === 62\n\t\t? 43\n\t\t: nUint6 === 63\n\t\t? 47\n\t\t: 65;\n}\n\nexport function toB64(aBytes: Uint8Array): string {\n\tvar nMod3 = 2,\n\t\tsB64Enc = '';\n\n\tfor (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\n\t\tnMod3 = nIdx % 3;\n\t\tnUint24 |= aBytes[nIdx] << ((16 >>> nMod3) & 24);\n\t\tif (nMod3 === 2 || aBytes.length - nIdx === 1) {\n\t\t\tsB64Enc += String.fromCodePoint(\n\t\t\t\tuint6ToB64((nUint24 >>> 18) & 63),\n\t\t\t\tuint6ToB64((nUint24 >>> 12) & 63),\n\t\t\t\tuint6ToB64((nUint24 >>> 6) & 63),\n\t\t\t\tuint6ToB64(nUint24 & 63),\n\t\t\t);\n\t\t\tnUint24 = 0;\n\t\t}\n\t}\n\n\treturn (\n\t\tsB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? '' : nMod3 === 1 ? '=' : '==')\n\t);\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHEX(hexStr: string): Uint8Array {\n\tconst normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n\tconst padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n\tconst intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n\treturn Uint8Array.from(intArr);\n}\n\nexport function toHEX(bytes: Uint8Array): string {\n\treturn bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n\tlet arr = [];\n\tlet len = 0;\n\n\tif (num === 0) {\n\t\treturn [0];\n\t}\n\n\twhile (num > 0) {\n\t\tarr[len] = num & 0x7f;\n\t\tif ((num >>= 7)) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0;\n\tlet shift = 0;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tlet byte = arr[len];\n\t\tlen += 1;\n\t\ttotal |= (byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7;\n\t}\n\n\treturn {\n\t\tvalue: total,\n\t\tlength: len,\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tlet value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tlet value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tlet value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tlet value1 = this.read32();\n\t\tlet value2 = this.read32();\n\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tlet value1 = BigInt(this.read64());\n\t\tlet value2 = BigInt(this.read64());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tlet value1 = BigInt(this.read128());\n\t\tlet value2 = BigInt(this.read128());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tlet { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tlet length = this.readULEB();\n\t\tlet result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58';\nimport { fromB64, toB64 } from './b64';\nimport { fromHEX, toHEX } from './hex';\nimport { Encoding } from './types';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toB58(data);\n\t\tcase 'base64':\n\t\t\treturn toB64(data);\n\t\tcase 'hex':\n\t\t\treturn toHEX(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromB58(data);\n\t\tcase 'base64':\n\t\t\treturn fromB64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHEX(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Encoding } from './types';\nimport { ulebEncode } from './uleb';\nimport { encodeStr } from './utils';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tsize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({ size = 1024, maxSize, allocateSize = 1024 }: BcsWriterOptions = {}) {\n\t\tthis.size = size;\n\t\tthis.maxSize = maxSize || size;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(size));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tlet result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB58 } from './b58';\nimport { toB64 } from './b64';\nimport { toHEX } from './hex';\nimport { BcsReader } from './reader';\nimport { ulebEncode } from './uleb';\nimport { BcsWriter, BcsWriterOptions } from './writer';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({ size: this.serializedSize(value) ?? undefined, ...options });\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\ttransform<T2, Input2>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t}: {\n\t\tinput: (val: Input2) => Input;\n\t\toutput: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => output(this.read(reader)),\n\t\t\twrite: (value, writer) => this.#write(input(value), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input(value)),\n\t\t\tserialize: (value, options) => this.#serialize(input(value), options),\n\t\t\tvalidate: (value) => this.validate(input(value)),\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs');\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHEX(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toB64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toB58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null)\n            this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n    return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    }\n    else if (result === false) {\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [result];\n    }\n    for (const r of result) {\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const ctx = { path, branch };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask &&\n            struct.type !== 'type' &&\n            isObject(struct.schema) &&\n            isObject(value) &&\n            !Array.isArray(value)) {\n            for (const key in value) {\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n        const ts = run(v, s, {\n            path: k === undefined ? path : [...path, k],\n            branch: k === undefined ? branch : [...branch, v],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const t of ts) {\n            if (t[0]) {\n                status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                yield [t[0], undefined];\n            }\n            else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                }\n                else if (value instanceof Map) {\n                    value.set(k, v);\n                }\n                else if (value instanceof Set) {\n                    value.add(v);\n                }\n                else if (isObject(value)) {\n                    if (v !== undefined || k in value)\n                        value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const t of tuples) {\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    else {\n        const v = tuple[1];\n        return [undefined, v];\n    }\n}\n\nfunction assign(...Structs) {\n    const isType = Structs[0].type === 'type';\n    const schemas = Structs.map((s) => s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n    const schema = struct instanceof Struct ? { ...struct.schema } : { ...struct };\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n    return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n    return define('any', () => true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()) {\n                    yield [i, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v) => print(v)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, ctx) {\n            for (const S of Structs) {\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator(value, ctx) {\n            for (const S of Structs) {\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner(value, ctx) {\n            for (const S of Structs) {\n                yield* S.refiner(value, ctx);\n            }\n        },\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()) {\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ? schema : null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k in value) {\n                    const v = value[k];\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const v of value) {\n                    yield [v, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n    const description = Structs.map((s) => s.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value) {\n            for (const S of Structs) {\n                const [error, coerced] = S.validate(value, { coerce: true });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const S of Structs) {\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                }\n                else {\n                    for (const [failure] of tuples) {\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n    return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationfor example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x) => {\n        const f = typeof fallback === 'function' ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = { ...x };\n            let changed = false;\n            for (const key in f) {\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n    return coerce(struct, string(), (x) => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((min <= value && value <= max) ||\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return ((min <= size && size <= max) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        else {\n            const { length } = value;\n            return ((min <= length && length <= max) ||\n                `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.mjs.map\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58.js';\nimport { fromB64, toB64 } from './b64.js';\nimport { BcsType } from './bcs-type.js';\nimport { fromHEX, toHEX } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { Encoding } from './types.js';\nimport { decodeStr, splitGenericParameters } from './utils.js';\nimport { BcsWriter, BcsWriterOptions } from './writer.js';\n\n/**\n * Allows for array definitions for names.\n * @example\n * ```\n * bcs.registerStructType(['vector', BCS.STRING], ...);\n * // equals\n * bcs.registerStructType('vector<string>', ...);\n * ```\n */\nexport type TypeName = string | [string, ...(TypeName | string)[]];\n\nconst SUI_ADDRESS_LENGTH = 32;\n\nexport interface TypeInterface {\n\tencode: (\n\t\tself: BCS,\n\t\tdata: any,\n\t\toptions: BcsWriterOptions | undefined,\n\t\ttypeParams: TypeName[],\n\t) => BcsWriter;\n\tdecode: (self: BCS, data: Uint8Array, typeParams: TypeName[]) => any;\n\n\t_encodeRaw: (\n\t\twriter: BcsWriter,\n\t\tdata: any,\n\t\ttypeParams: TypeName[],\n\t\ttypeMap: { [key: string]: TypeName },\n\t) => BcsWriter;\n\t_decodeRaw: (\n\t\treader: BcsReader,\n\t\ttypeParams: TypeName[],\n\t\ttypeMap: { [key: string]: TypeName },\n\t) => any;\n}\n\n/**\n * Struct type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerStructType`.\n */\nexport type StructTypeDefinition = {\n\t[key: string]: TypeName | StructTypeDefinition;\n};\n\n/**\n * Enum type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerEnumType`.\n *\n * Value can be either `string` when invariant has a type or `null`\n * when invariant is empty.\n *\n * @example\n * bcs.registerEnumType('Option<T>', {\n *   some: 'T',\n *   none: null\n * });\n */\nexport type EnumTypeDefinition = {\n\t[key: string]: TypeName | StructTypeDefinition | null;\n};\n\n/**\n * Configuration that is passed into BCS constructor.\n */\nexport type BcsConfig = {\n\t/**\n\t * Defines type name for the vector / array type.\n\t * In Move: `vector<T>` or `vector`.\n\t */\n\tvectorType: string;\n\t/**\n\t * Address length. Varies depending on a platform and\n\t * has to be specified for the `address` type.\n\t */\n\taddressLength: number;\n\n\t/**\n\t * Custom encoding for address. Supported values are\n\t * either 'hex' or 'base64'.\n\t */\n\taddressEncoding?: 'hex' | 'base64';\n\t/**\n\t * Opening and closing symbol for type parameters. Can be\n\t * any pair of symbols (eg `['(', ')']`); default value follows\n\t * Rust and Move: `<` and `>`.\n\t */\n\tgenericSeparators?: [string, string];\n\t/**\n\t * Type definitions for the BCS. This field allows spawning\n\t * BCS instance from JSON or another prepared configuration.\n\t * Optional.\n\t */\n\ttypes?: {\n\t\tstructs?: { [key: string]: StructTypeDefinition };\n\t\tenums?: { [key: string]: EnumTypeDefinition };\n\t\taliases?: { [key: string]: string };\n\t};\n\t/**\n\t * Whether to auto-register primitive types on launch.\n\t */\n\twithPrimitives?: boolean;\n};\n\n/**\n * BCS implementation for Move types and few additional built-ins.\n */\nexport class BCS {\n\t// Predefined types constants\n\tstatic readonly U8 = 'u8';\n\tstatic readonly U16 = 'u16';\n\tstatic readonly U32 = 'u32';\n\tstatic readonly U64 = 'u64';\n\tstatic readonly U128 = 'u128';\n\tstatic readonly U256 = 'u256';\n\tstatic readonly BOOL = 'bool';\n\tstatic readonly VECTOR = 'vector';\n\tstatic readonly ADDRESS = 'address';\n\tstatic readonly STRING = 'string';\n\tstatic readonly HEX = 'hex-string';\n\tstatic readonly BASE58 = 'base58-string';\n\tstatic readonly BASE64 = 'base64-string';\n\n\t/**\n\t * Map of kind `TypeName => TypeInterface`. Holds all\n\t * callbacks for (de)serialization of every registered type.\n\t *\n\t * If the value stored is a string, it is treated as an alias.\n\t */\n\tpublic types: Map<string, TypeInterface | string> = new Map();\n\n\t/**\n\t * Stored BcsConfig for the current instance of BCS.\n\t */\n\tprotected schema: BcsConfig;\n\n\t/**\n\t * Count temp keys to generate a new one when requested.\n\t */\n\tprotected counter: number = 0;\n\n\t/**\n\t * Name of the key to use for temporary struct definitions.\n\t * Returns a temp key + index (for a case when multiple temp\n\t * structs are processed).\n\t */\n\tprivate tempKey() {\n\t\treturn `bcs-struct-${++this.counter}`;\n\t}\n\n\t/**\n\t * Construct a BCS instance with a prepared schema.\n\t *\n\t * @param schema A prepared schema with type definitions\n\t * @param withPrimitives Whether to register primitive types by default\n\t */\n\tconstructor(schema: BcsConfig | BCS) {\n\t\t// if BCS instance is passed -> clone its schema\n\t\tif (schema instanceof BCS) {\n\t\t\tthis.schema = schema.schema;\n\t\t\tthis.types = new Map(schema.types);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.schema = schema;\n\n\t\t// Register address type under key 'address'.\n\t\tthis.registerAddressType(BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\n\t\tthis.registerVectorType(schema.vectorType);\n\n\t\t// Register struct types if they were passed.\n\t\tif (schema.types && schema.types.structs) {\n\t\t\tfor (let name of Object.keys(schema.types.structs)) {\n\t\t\t\tthis.registerStructType(name, schema.types.structs[name]);\n\t\t\t}\n\t\t}\n\n\t\t// Register enum types if they were passed.\n\t\tif (schema.types && schema.types.enums) {\n\t\t\tfor (let name of Object.keys(schema.types.enums)) {\n\t\t\t\tthis.registerEnumType(name, schema.types.enums[name]);\n\t\t\t}\n\t\t}\n\n\t\t// Register aliases if they were passed.\n\t\tif (schema.types && schema.types.aliases) {\n\t\t\tfor (let name of Object.keys(schema.types.aliases)) {\n\t\t\t\tthis.registerAlias(name, schema.types.aliases[name]);\n\t\t\t}\n\t\t}\n\n\t\tif (schema.withPrimitives !== false) {\n\t\t\tregisterPrimitives(this);\n\t\t}\n\t}\n\n\t/**\n\t * Serialize data into bcs.\n\t *\n\t * @example\n\t * bcs.registerVectorType('vector<u8>', 'u8');\n\t *\n\t * let serialized = BCS\n\t *   .set('vector<u8>', [1,2,3,4,5,6])\n\t *   .toBytes();\n\t *\n\t * console.assert(toHex(serialized) === '06010203040506');\n\t *\n\t * @param type Name of the type to serialize (must be registered) or a struct type.\n\t * @param data Data to serialize.\n\t * @param size Serialization buffer size. Default 1024 = 1KB.\n\t * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n\t */\n\tpublic ser(\n\t\ttype: TypeName | StructTypeDefinition,\n\t\tdata: any,\n\t\toptions?: BcsWriterOptions,\n\t): BcsWriter {\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\n\t\t\tconst { name, params } = this.parseTypeName(type);\n\t\t\treturn this.getTypeInterface(name).encode(this, data, options, params as string[]);\n\t\t}\n\n\t\t// Quick serialization without registering the type in the main struct.\n\t\tif (typeof type === 'object') {\n\t\t\tconst key = this.tempKey();\n\t\t\tconst temp = new BCS(this);\n\t\t\treturn temp.registerStructType(key, type).ser(key, data, options);\n\t\t}\n\n\t\tthrow new Error(`Incorrect type passed into the '.ser()' function. \\n${JSON.stringify(type)}`);\n\t}\n\n\t/**\n\t * Deserialize BCS into a JS type.\n\t *\n\t * @example\n\t * let num = bcs.ser('u64', '4294967295').toString('hex');\n\t * let deNum = bcs.de('u64', num, 'hex');\n\t * console.assert(deNum.toString(10) === '4294967295');\n\t *\n\t * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n\t * @param data Data to deserialize.\n\t * @param encoding Optional - encoding to use if data is of type String\n\t * @return Deserialized data.\n\t */\n\tpublic de(\n\t\ttype: TypeName | StructTypeDefinition,\n\t\tdata: Uint8Array | string,\n\t\tencoding?: Encoding,\n\t): any {\n\t\tif (typeof data === 'string') {\n\t\t\tif (encoding) {\n\t\t\t\tdata = decodeStr(data, encoding);\n\t\t\t} else {\n\t\t\t\tthrow new Error('To pass a string to `bcs.de`, specify encoding');\n\t\t\t}\n\t\t}\n\n\t\t// In case the type specified is already registered.\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\n\t\t\tconst { name, params } = this.parseTypeName(type);\n\t\t\treturn this.getTypeInterface(name).decode(this, data, params as string[]);\n\t\t}\n\n\t\t// Deserialize without registering a type using a temporary clone.\n\t\tif (typeof type === 'object') {\n\t\t\tconst temp = new BCS(this);\n\t\t\tconst key = this.tempKey();\n\t\t\treturn temp.registerStructType(key, type).de(key, data, encoding);\n\t\t}\n\n\t\tthrow new Error(`Incorrect type passed into the '.de()' function. \\n${JSON.stringify(type)}`);\n\t}\n\n\t/**\n\t * Check whether a `TypeInterface` has been loaded for a `type`.\n\t * @param type Name of the type to check.\n\t * @returns\n\t */\n\tpublic hasType(type: string): boolean {\n\t\treturn this.types.has(type);\n\t}\n\n\t/**\n\t * Create an alias for a type.\n\t * WARNING: this can potentially lead to recursion\n\t * @param name Alias to use\n\t * @param forType Type to reference\n\t * @returns\n\t *\n\t * @example\n\t * ```\n\t * let bcs = new BCS(getSuiMoveConfig());\n\t * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n\t * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n\t * ```\n\t */\n\tpublic registerAlias(name: string, forType: string): BCS {\n\t\tthis.types.set(name, forType);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Method to register new types for BCS internal representation.\n\t * For each registered type 2 callbacks must be specified and one is optional:\n\t *\n\t * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n\t * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n\t * - validateCb(data) - validate data - either return bool or throw an error\n\t *\n\t * @example\n\t * // our type would be a string that consists only of numbers\n\t * bcs.registerType('number_string',\n\t *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n\t *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n\t *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n\t * );\n\t * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n\t *\n\t * @param name\n\t * @param encodeCb Callback to encode a value.\n\t * @param decodeCb Callback to decode a value.\n\t * @param validateCb Optional validator Callback to check type before serialization.\n\t */\n\tpublic registerType(\n\t\ttypeName: TypeName,\n\t\tencodeCb: (\n\t\t\twriter: BcsWriter,\n\t\t\tdata: any,\n\t\t\ttypeParams: TypeName[],\n\t\t\ttypeMap: { [key: string]: TypeName },\n\t\t) => BcsWriter,\n\t\tdecodeCb: (\n\t\t\treader: BcsReader,\n\t\t\ttypeParams: TypeName[],\n\t\t\ttypeMap: { [key: string]: TypeName },\n\t\t) => any,\n\t\tvalidateCb: (data: any) => boolean = () => true,\n\t): BCS {\n\t\tconst { name, params: generics } = this.parseTypeName(typeName);\n\n\t\tthis.types.set(name, {\n\t\t\tencode(self: BCS, data, options: BcsWriterOptions, typeParams) {\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t}, {});\n\n\t\t\t\treturn this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);\n\t\t\t},\n\t\t\tdecode(self: BCS, data, typeParams) {\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t}, {});\n\n\t\t\t\treturn this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);\n\t\t\t},\n\n\t\t\t// these methods should always be used with caution as they require pre-defined\n\t\t\t// reader and writer and mainly exist to allow multi-field (de)serialization;\n\t\t\t_encodeRaw(writer, data, typeParams, typeMap) {\n\t\t\t\tif (validateCb(data)) {\n\t\t\t\t\treturn encodeCb.call(this, writer, data, typeParams, typeMap);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`Validation failed for type ${name}, data: ${data}`);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_decodeRaw(reader, typeParams, typeMap) {\n\t\t\t\treturn decodeCb.call(this, reader, typeParams, typeMap);\n\t\t\t},\n\t\t} as TypeInterface);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Method to register BcsType instances to the registry\n\t * Types are registered with a callback that provides BcsType instances for each generic\n\t * passed to the type.\n\t *\n\t * - createType(...generics) - Return a BcsType instance\n\t *\n\t * @example\n\t * // our type would be a string that consists only of numbers\n\t * bcs.registerType('Box<T>', (T) => {\n\t * \t\treturn bcs.struct({\n\t * \t\t\tvalue: T\n\t * \t\t});\n\t * });\n\n\t * console.log(Array.from(bcs.ser('Box<string>', '12345').toBytes()) == [5,1,2,3,4,5]);\n\t *\n\t * @param name\n\t * @param createType a Callback to create the BcsType with any passed in generics\n\t */\n\tpublic registerBcsType(\n\t\ttypeName: TypeName,\n\t\tcreateType: (...params: BcsType<any>[]) => BcsType<any>,\n\t) {\n\t\tthis.registerType(\n\t\t\ttypeName,\n\t\t\t(writer, data, typeParams) => {\n\t\t\t\tconst generics = typeParams.map(\n\t\t\t\t\t(param) =>\n\t\t\t\t\t\tnew BcsType<unknown>({\n\t\t\t\t\t\t\tname: String(param),\n\t\t\t\t\t\t\twrite: (data, writer) => {\n\t\t\t\t\t\t\t\tconst { name, params } = this.parseTypeName(param);\n\t\t\t\t\t\t\t\tconst typeInterface = this.getTypeInterface(name);\n\n\t\t\t\t\t\t\t\tconst typeMap = (params as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\t\t\treturn typeInterface._encodeRaw.call(this, writer, data, params, typeMap);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tread: () => {\n\t\t\t\t\t\t\t\tthrow new Error('Not implemented');\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\tcreateType(...generics).write(data, writer);\n\t\t\t\treturn writer;\n\t\t\t},\n\t\t\t(reader, typeParams) => {\n\t\t\t\tconst generics = typeParams.map(\n\t\t\t\t\t(param) =>\n\t\t\t\t\t\tnew BcsType<unknown>({\n\t\t\t\t\t\t\tname: String(param),\n\t\t\t\t\t\t\twrite: (data, writer) => {\n\t\t\t\t\t\t\t\tthrow new Error('Not implemented');\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tread: (reader) => {\n\t\t\t\t\t\t\t\tconst { name, params } = this.parseTypeName(param);\n\t\t\t\t\t\t\t\tconst typeInterface = this.getTypeInterface(name);\n\n\t\t\t\t\t\t\t\tconst typeMap = (params as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\t\t\treturn typeInterface._decodeRaw.call(this, reader, params, typeMap);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\treturn createType(...generics).read(reader);\n\t\t\t},\n\t\t);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Register an address type which is a sequence of U8s of specified length.\n\t * @example\n\t * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n\t * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n\t *\n\t * @param name Name of the address type.\n\t * @param length Byte length of the address.\n\t * @param encoding Encoding to use for the address type\n\t * @returns\n\t */\n\tpublic registerAddressType(name: string, length: number, encoding: Encoding | void = 'hex'): BCS {\n\t\tswitch (encoding) {\n\t\t\tcase 'base64':\n\t\t\t\treturn this.registerType(\n\t\t\t\t\tname,\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\n\t\t\t\t\t\treturn fromB64(data).reduce((writer, el) => writer.write8(el), writer);\n\t\t\t\t\t},\n\t\t\t\t\tfunction decodeAddress(reader) {\n\t\t\t\t\t\treturn toB64(reader.readBytes(length));\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\tcase 'hex':\n\t\t\t\treturn this.registerType(\n\t\t\t\t\tname,\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\n\t\t\t\t\t\treturn fromHEX(data).reduce((writer, el) => writer.write8(el), writer);\n\t\t\t\t\t},\n\t\t\t\t\tfunction decodeAddress(reader) {\n\t\t\t\t\t\treturn toHEX(reader.readBytes(length));\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unsupported encoding! Use either hex or base64');\n\t\t}\n\t}\n\n\t/**\n\t * Register custom vector type inside the bcs.\n\t *\n\t * @example\n\t * bcs.registerVectorType('vector<T>'); // generic registration\n\t * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n\t * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n\t *\n\t * @param name Name of the type to register\n\t * @param elementType Optional name of the inner type of the vector\n\t * @return Returns self for chaining.\n\t */\n\tprivate registerVectorType(typeName: string): BCS {\n\t\tlet { name, params } = this.parseTypeName(typeName);\n\t\tif (params.length > 1) {\n\t\t\tthrow new Error('Vector can have only one type parameter; got ' + name);\n\t\t}\n\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeVector(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: any[],\n\t\t\t\ttypeParams: TypeName[],\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\treturn writer.writeVec(data, (writer, el) => {\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\n\t\t\t\t\tif (!elementType) {\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\n\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(this, writer, el, params, typeMap);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\n\t\t\t\t\treturn this.getTypeInterface(innerName)._encodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\twriter,\n\t\t\t\t\t\tel,\n\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t\tfunction decodeVector(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\treturn reader.readVec((reader) => {\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\n\t\t\t\t\tif (!elementType) {\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\n\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\treturn this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\n\t\t\t\t\treturn this.getTypeInterface(innerName)._decodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\treader,\n\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Safe method to register a custom Move struct. The first argument is a name of the\n\t * struct which is only used on the FrontEnd and has no affect on serialization results,\n\t * and the second is a struct description passed as an Object.\n\t *\n\t * The description object MUST have the same order on all of the platforms (ie in Move\n\t * or in Rust).\n\t *\n\t * @example\n\t * // Move / Rust struct\n\t * // struct Coin {\n\t * //   value: u64,\n\t * //   owner: vector<u8>, // name // Vec<u8> in Rust\n\t * //   is_locked: bool,\n\t * // }\n\t *\n\t * bcs.registerStructType('Coin', {\n\t *   value: bcs.U64,\n\t *   owner: bcs.STRING,\n\t *   is_locked: bcs.BOOL\n\t * });\n\t *\n\t * // Created in Rust with diem/bcs\n\t * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n\t * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n\t *  128, 209, 177,   5,  96,  0,  0,\n\t *    0,  14,  66, 105, 103, 32, 87,\n\t *   97, 108, 108, 101, 116, 32, 71,\n\t *  117, 121,   0\n\t * ];\n\t *\n\t * // Let's encode the value as well\n\t * let test_set = bcs.ser('Coin', {\n\t *   owner: 'Big Wallet Guy',\n\t *   value: '412412400000',\n\t *   is_locked: false,\n\t * });\n\t *\n\t * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n\t *\n\t * @param name Name of the type to register.\n\t * @param fields Fields of the struct. Must be in the correct order.\n\t * @return Returns BCS for chaining.\n\t */\n\tpublic registerStructType(typeName: TypeName, fields: StructTypeDefinition): BCS {\n\t\t// When an Object is passed, we register it under a new key and store it\n\t\t// in the registered type system. This way we allow nested inline definitions.\n\t\tfor (let key in fields) {\n\t\t\tlet internalName = this.tempKey();\n\t\t\tlet value = fields[key];\n\n\t\t\t// TODO: add a type guard here?\n\t\t\tif (!Array.isArray(value) && typeof value !== 'string') {\n\t\t\t\tfields[key] = internalName;\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\n\t\t\t}\n\t\t}\n\n\t\tlet struct = Object.freeze(fields); // Make sure the order doesn't get changed\n\n\t\t// IMPORTANT: we need to store canonical order of fields for each registered\n\t\t// struct so we maintain it and allow developers to use any field ordering in\n\t\t// their code (and not cause mismatches based on field order).\n\t\tlet canonicalOrder = Object.keys(struct);\n\n\t\t// Holds generics for the struct definition. At this stage we can check that\n\t\t// generic parameter matches the one defined in the struct.\n\t\tlet { name: structName, params: generics } = this.parseTypeName(typeName);\n\n\t\t// Make sure all the types in the fields description are already known\n\t\t// and that all the field types are strings.\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeStruct(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: { [key: string]: any },\n\t\t\t\ttypeParams,\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\tif (!data || data.constructor !== Object) {\n\t\t\t\t\tthrow new Error(`Expected ${structName} to be an Object, got: ${data}`);\n\t\t\t\t}\n\n\t\t\t\tif (typeParams.length !== generics.length) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// follow the canonical order when serializing\n\t\t\t\tfor (let key of canonicalOrder) {\n\t\t\t\t\tif (!(key in data)) {\n\t\t\t\t\t\tthrow new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Before deserializing, read the canonical field type.\n\t\t\t\t\tconst { name: fieldType, params: fieldParams } = this.parseTypeName(\n\t\t\t\t\t\tstruct[key] as TypeName,\n\t\t\t\t\t);\n\n\t\t\t\t\t// Check whether this type is a generic defined in this struct.\n\t\t\t\t\t// If it is -> read the type parameter matching its index.\n\t\t\t\t\t// If not - tread as a regular field.\n\t\t\t\t\tif (!generics.includes(fieldType)) {\n\t\t\t\t\t\tthis.getTypeInterface(fieldType)._encodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\tfieldParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldType);\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n\t\t\t\t\t\t// If the type from the type parameters already exists\n\t\t\t\t\t\t// and known -> proceed with type decoding.\n\t\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\t\tthis.getTypeInterface(name)._encodeRaw.call(\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\t\tparams as string[],\n\t\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Alternatively, if it's a global generic parameter...\n\t\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\t\t\t\t\t\tthis.getTypeInterface(innerName)._encodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn writer;\n\t\t\t},\n\t\t\tfunction decodeStruct(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\tif (typeParams.length !== generics.length) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet result: { [key: string]: any } = {};\n\t\t\t\tfor (let key of canonicalOrder) {\n\t\t\t\t\tconst { name: fieldName, params: fieldParams } = this.parseTypeName(\n\t\t\t\t\t\tstruct[key] as TypeName,\n\t\t\t\t\t);\n\n\t\t\t\t\t// if it's not a generic\n\t\t\t\t\tif (!generics.includes(fieldName)) {\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(fieldName)._decodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\tfieldParams as string[],\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldName);\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n\t\t\t\t\t\t// If the type from the type parameters already exists\n\t\t\t\t\t\t// and known -> proceed with type decoding.\n\t\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\t\tresult[key] = this.getTypeInterface(name)._decodeRaw.call(\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\t\tparams,\n\t\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(innerName)._decodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Safe method to register custom enum type where each invariant holds the value of another type.\n\t * @example\n\t * bcs.registerStructType('Coin', { value: 'u64' });\n\t * bcs.registerEnumType('MyEnum', {\n\t *  single: 'Coin',\n\t *  multi: 'vector<Coin>',\n\t *  empty: null\n\t * });\n\t *\n\t * console.log(\n\t *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n\t *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n\t * )\n\t *\n\t * // and serialization\n\t * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n\t * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n\t *\n\t * @param name\n\t * @param variants\n\t */\n\tpublic registerEnumType(typeName: TypeName, variants: EnumTypeDefinition): BCS {\n\t\t// When an Object is passed, we register it under a new key and store it\n\t\t// in the registered type system. This way we allow nested inline definitions.\n\t\tfor (let key in variants) {\n\t\t\tlet internalName = this.tempKey();\n\t\t\tlet value = variants[key];\n\n\t\t\tif (value !== null && !Array.isArray(value) && typeof value !== 'string') {\n\t\t\t\tvariants[key] = internalName;\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\n\t\t\t}\n\t\t}\n\n\t\tlet struct = Object.freeze(variants); // Make sure the order doesn't get changed\n\n\t\t// IMPORTANT: enum is an ordered type and we have to preserve ordering in BCS\n\t\tlet canonicalOrder = Object.keys(struct);\n\n\t\t// Parse type parameters in advance to know the index of each generic parameter.\n\t\tlet { name, params: canonicalTypeParams } = this.parseTypeName(typeName);\n\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeEnum(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: { [key: string]: any | null },\n\t\t\t\ttypeParams,\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\tif (!data) {\n\t\t\t\t\tthrow new Error(`Unable to write enum \"${name}\", missing data.\\nReceived: \"${data}\"`);\n\t\t\t\t}\n\t\t\t\tif (typeof data !== 'object') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\n\t\t\t\t\t\t\t' | ',\n\t\t\t\t\t\t)}\".\\nReceived: \"${JSON.stringify(data)}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet key = Object.keys(data)[0];\n\t\t\t\tif (key === undefined) {\n\t\t\t\t\tthrow new Error(`Empty object passed as invariant of the enum \"${name}\"`);\n\t\t\t\t}\n\n\t\t\t\tlet orderByte = canonicalOrder.indexOf(key);\n\t\t\t\tif (orderByte === -1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\n\t\t\t\t\t\t\t' | ',\n\t\t\t\t\t\t)}\"; received \"${key}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\n\n\t\t\t\t// write order byte\n\t\t\t\twriter.write8(orderByte);\n\n\t\t\t\t// When { \"key\": null } - empty value for the invariant.\n\t\t\t\tif (invariantType === null) {\n\t\t\t\t\treturn writer;\n\t\t\t\t}\n\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n\t\t\t\t{\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\n\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\twriter,\n\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\tparams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction decodeEnum(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\tlet orderByte = reader.readULEB();\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\n\n\t\t\t\tif (orderByte === -1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Encode an empty value for the enum.\n\t\t\t\tif (invariantType === null) {\n\t\t\t\t\treturn { [invariant]: true };\n\t\t\t\t}\n\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n\t\t\t\t{\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[invariant]: this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t}\n\t/**\n\t * Get a set of encoders/decoders for specific type.\n\t * Mainly used to define custom type de/serialization logic.\n\t *\n\t * @param type\n\t * @returns {TypeInterface}\n\t */\n\tpublic getTypeInterface(type: string): TypeInterface {\n\t\tlet typeInterface = this.types.get(type);\n\n\t\t// Special case - string means an alias.\n\t\t// Goes through the alias chain and tracks recursion.\n\t\tif (typeof typeInterface === 'string') {\n\t\t\tlet chain: string[] = [];\n\t\t\twhile (typeof typeInterface === 'string') {\n\t\t\t\tif (chain.includes(typeInterface)) {\n\t\t\t\t\tthrow new Error(`Recursive definition found: ${chain.join(' -> ')} -> ${typeInterface}`);\n\t\t\t\t}\n\t\t\t\tchain.push(typeInterface);\n\t\t\t\ttypeInterface = this.types.get(typeInterface);\n\t\t\t}\n\t\t}\n\n\t\tif (typeInterface === undefined) {\n\t\t\tthrow new Error(`Type ${type} is not registered`);\n\t\t}\n\n\t\treturn typeInterface;\n\t}\n\n\t/**\n\t * Parse a type name and get the type's generics.\n\t * @example\n\t * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n\t * // typeName: Option\n\t * // typeParams: [ 'Coin<SUI>' ]\n\t *\n\t * @param name Name of the type to process\n\t * @returns Object with typeName and typeParams listed as Array\n\t */\n\tpublic parseTypeName(name: TypeName): {\n\t\tname: string;\n\t\tparams: TypeName[];\n\t} {\n\t\tif (Array.isArray(name)) {\n\t\t\tlet [typeName, ...params] = name;\n\t\t\treturn { name: typeName, params };\n\t\t}\n\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new Error(`Illegal type passed as a name of the type: ${name}`);\n\t\t}\n\n\t\tlet [left, right] = this.schema.genericSeparators || ['<', '>'];\n\n\t\tlet l_bound = name.indexOf(left);\n\t\tlet r_bound = Array.from(name).reverse().indexOf(right);\n\n\t\t// if there are no generics - exit gracefully.\n\t\tif (l_bound === -1 && r_bound === -1) {\n\t\t\treturn { name: name, params: [] };\n\t\t}\n\n\t\t// if one of the bounds is not defined - throw an Error.\n\t\tif (l_bound === -1 || r_bound === -1) {\n\t\t\tthrow new Error(`Unclosed generic in name '${name}'`);\n\t\t}\n\n\t\tlet typeName = name.slice(0, l_bound);\n\t\tlet params = splitGenericParameters(\n\t\t\tname.slice(l_bound + 1, name.length - r_bound - 1),\n\t\t\tthis.schema.genericSeparators,\n\t\t);\n\n\t\treturn { name: typeName, params };\n\t}\n}\n\n/**\n * Register the base set of primitive and common types.\n * Is called in the `BCS` constructor automatically but can\n * be ignored if the `withPrimitives` argument is not set.\n */\nexport function registerPrimitives(bcs: BCS): void {\n\tbcs.registerType(\n\t\tBCS.U8,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write8(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read8();\n\t\t},\n\t\t(u8) => u8 < 256,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U16,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write16(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read16();\n\t\t},\n\t\t(u16) => u16 < 65536,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U32,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write32(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read32();\n\t\t},\n\t\t(u32) => u32 <= 4294967296n,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U64,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write64(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read64();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U128,\n\t\tfunction (writer: BcsWriter, data: bigint) {\n\t\t\treturn writer.write128(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read128();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U256,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write256(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read256();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BOOL,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write8(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read8().toString(10) === '1';\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.STRING,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(data), (writer, el) => writer.write8(el.charCodeAt(0)));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader\n\t\t\t\t.readVec((reader) => reader.read8())\n\t\t\t\t.map((el: bigint) => String.fromCharCode(Number(el)))\n\t\t\t\t.join('');\n\t\t},\n\t\t(_str: string) => true,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.HEX,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromHEX(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toHEX(new Uint8Array(bytes));\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BASE58,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromB58(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toB58(new Uint8Array(bytes));\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BASE64,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromB64(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toB64(new Uint8Array(bytes));\n\t\t},\n\t);\n}\n\nexport function getRustConfig(): BcsConfig {\n\treturn {\n\t\tgenericSeparators: ['<', '>'],\n\t\tvectorType: 'Vec',\n\t\taddressLength: SUI_ADDRESS_LENGTH,\n\t\taddressEncoding: 'hex',\n\t};\n}\n\nexport function getSuiMoveConfig(): BcsConfig {\n\treturn {\n\t\tgenericSeparators: ['<', '>'],\n\t\tvectorType: 'vector',\n\t\taddressLength: SUI_ADDRESS_LENGTH,\n\t\taddressEncoding: 'hex',\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tBcsType,\n\tBcsTypeOptions,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport { GenericPlaceholder, ReplaceBcsGenerics } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(value[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif ('Some' in value) {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any>\n\t\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t\t: { [K2 in K]: true };\n\t\t\t\t}[keyof T],\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U>\n\t\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t\t: { [K2 in K]: unknown };\n\t\t\t\t}[keyof T]\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? { [K2 in K]: U } : { [K2 in K]: true };\n\t\t\t}[keyof T],\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U>\n\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t: { [K2 in K]: unknown };\n\t\t\t}[keyof T]\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\t\t\t\tconst [name, type] = canonicalOrder[index];\n\t\t\t\treturn {\n\t\t\t\t\t[name]: type?.read(reader) ?? true,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value)[0];\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value);\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(`Expected object with one key, found ${keys.length}`);\n\t\t\t\t}\n\n\t\t\t\tconst [name] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, name)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${name}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * @deprecated\n\t *\n\t * Generics should be implemented as generic typescript functions instead:\n\t *\n\t * ```ts\n\t * function VecMap<K, V>, (K: BcsType<K>, V: BcsType<V>) {\n\t *   return bcs.struct('VecMap<K, V>', {\n\t *     keys: bcs.vector(K),\n\t *     values: bcs.vector(V),\n\t *   })\n\t * }\n\t * ```\n\t */\n\tgeneric<const Names extends readonly string[], const Type extends BcsType<any>>(\n\t\tnames: Names,\n\t\tcb: (...types: { [K in keyof Names]: BcsType<GenericPlaceholder<Names[K]>> }) => Type,\n\t): <T extends { [K in keyof Names]: BcsType<any> }>(\n\t\t...types: T\n\t) => ReplaceBcsGenerics<Type, Names, T> {\n\t\treturn (...types) => {\n\t\t\treturn cb(...types).transform({\n\t\t\t\tname: `${cb.name}<${types.map((t) => t.name).join(', ')}>`,\n\t\t\t\tinput: (value) => value,\n\t\t\t\toutput: (value) => value,\n\t\t\t}) as never;\n\t\t};\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, splitGenericParameters } from '@mysten/bcs';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n\ttry {\n\t\tconst buffer = fromB58(value);\n\t\treturn buffer.length === TX_DIGEST_LENGTH;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is string {\n\treturn isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n\treturn isValidSuiAddress(value);\n}\n\ntype StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n\tif (!type.includes('::')) return type;\n\n\treturn parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n\tconst [address, module] = type.split('::');\n\n\tconst rest = type.slice(address.length + module.length + 4);\n\tconst name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n\tconst typeParams = rest.includes('<')\n\t\t? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n\t\t\t\t(typeParam) => parseTypeTag(typeParam.trim()),\n\t\t  )\n\t\t: [];\n\n\treturn {\n\t\taddress: normalizeSuiAddress(address),\n\t\tmodule,\n\t\tname,\n\t\ttypeParams,\n\t};\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n\tconst { address, module, name, typeParams } =\n\t\ttypeof type === 'string' ? parseStructTag(type) : type;\n\n\tconst formattedTypeParams =\n\t\ttypeParams.length > 0\n\t\t\t? `<${typeParams\n\t\t\t\t\t.map((typeParam) =>\n\t\t\t\t\t\ttypeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n\t\t\t\t\t)\n\t\t\t\t\t.join(',')}>`\n\t\t\t: '';\n\n\treturn `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(value: string, forceAdd0x: boolean = false): string {\n\tlet address = value.toLowerCase();\n\tif (!forceAdd0x && address.startsWith('0x')) {\n\t\taddress = address.slice(2);\n\t}\n\treturn `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(value: string, forceAdd0x: boolean = false): string {\n\treturn normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n\treturn /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n\treturn /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TypeTag } from './index.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n\tstatic parseFromStr(str: string, normalizeAddress = false): TypeTag {\n\t\tif (str === 'address') {\n\t\t\treturn { address: null };\n\t\t} else if (str === 'bool') {\n\t\t\treturn { bool: null };\n\t\t} else if (str === 'u8') {\n\t\t\treturn { u8: null };\n\t\t} else if (str === 'u16') {\n\t\t\treturn { u16: null };\n\t\t} else if (str === 'u32') {\n\t\t\treturn { u32: null };\n\t\t} else if (str === 'u64') {\n\t\t\treturn { u64: null };\n\t\t} else if (str === 'u128') {\n\t\t\treturn { u128: null };\n\t\t} else if (str === 'u256') {\n\t\t\treturn { u256: null };\n\t\t} else if (str === 'signer') {\n\t\t\treturn { signer: null };\n\t\t}\n\t\tconst vectorMatch = str.match(VECTOR_REGEX);\n\t\tif (vectorMatch) {\n\t\t\treturn {\n\t\t\t\tvector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n\t\t\t};\n\t\t}\n\n\t\tconst structMatch = str.match(STRUCT_REGEX);\n\t\tif (structMatch) {\n\t\t\tconst address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n\t\t\treturn {\n\t\t\t\tstruct: {\n\t\t\t\t\taddress,\n\t\t\t\t\tmodule: structMatch[2],\n\t\t\t\t\tname: structMatch[3],\n\t\t\t\t\ttypeParams:\n\t\t\t\t\t\tstructMatch[5] === undefined\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error(`Encountered unexpected token when parsing type args for ${str}`);\n\t}\n\n\tstatic parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n\t\treturn splitGenericParameters(str).map((tok) =>\n\t\t\tTypeTagSerializer.parseFromStr(tok, normalizeAddress),\n\t\t);\n\t}\n\n\tstatic tagToString(tag: TypeTag): string {\n\t\tif ('bool' in tag) {\n\t\t\treturn 'bool';\n\t\t}\n\t\tif ('u8' in tag) {\n\t\t\treturn 'u8';\n\t\t}\n\t\tif ('u16' in tag) {\n\t\t\treturn 'u16';\n\t\t}\n\t\tif ('u32' in tag) {\n\t\t\treturn 'u32';\n\t\t}\n\t\tif ('u64' in tag) {\n\t\t\treturn 'u64';\n\t\t}\n\t\tif ('u128' in tag) {\n\t\t\treturn 'u128';\n\t\t}\n\t\tif ('u256' in tag) {\n\t\t\treturn 'u256';\n\t\t}\n\t\tif ('address' in tag) {\n\t\t\treturn 'address';\n\t\t}\n\t\tif ('signer' in tag) {\n\t\t\treturn 'signer';\n\t\t}\n\t\tif ('vector' in tag) {\n\t\t\treturn `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n\t\t}\n\t\tif ('struct' in tag) {\n\t\t\tconst struct = tag.struct;\n\t\t\tconst typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n\t\t\treturn `${struct.address}::${struct.module}::${struct.name}${\n\t\t\t\ttypeParams ? `<${typeParams}>` : ''\n\t\t\t}`;\n\t\t}\n\t\tthrow new Error('Invalid TypeTag');\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tbcs,\n\tBCS as BcsRegistry,\n\tfromB58,\n\tfromHEX,\n\tgetSuiMoveConfig,\n\ttoB58,\n\ttoHEX,\n} from '@mysten/bcs';\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\n\nimport type { MoveCallTransaction } from '../builder/Transactions.js';\nimport type { SuiObjectRef as SuiObjectRefType } from '../types/objects.js';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\n\n/**\n * A reference to a shared object.\n */\nexport type SharedObjectRef = {\n\t/** Hex code as string representing the object id */\n\tobjectId: string;\n\n\t/** The version the object was shared at */\n\tinitialSharedVersion: number | string;\n\n\t/** Whether reference is mutable */\n\tmutable: boolean;\n};\n\n/**\n * An object argument.\n */\nexport type ObjectArg =\n\t| { ImmOrOwned: SuiObjectRefType }\n\t| { Shared: SharedObjectRef }\n\t| { Receiving: SuiObjectRefType };\n\n/**\n * A pure argument.\n */\nexport type PureArg = { Pure: ArrayLike<number> };\n\nexport function isPureArg(arg: any): arg is PureArg {\n\treturn (arg as PureArg).Pure !== undefined;\n}\n\n/**\n * An argument for the transaction. It is a 'meant' enum which expects to have\n * one of the optional properties. If not, the BCS error will be thrown while\n * attempting to form a transaction.\n *\n * Example:\n * ```js\n * let arg1: CallArg = { Object: { Shared: {\n *   objectId: '5460cf92b5e3e7067aaace60d88324095fd22944',\n *   initialSharedVersion: 1,\n *   mutable: true,\n * } } };\n * let arg2: CallArg = { Pure: bcs.ser(BCS.STRING, 100000).toBytes() };\n * let arg3: CallArg = { Object: { ImmOrOwned: {\n *   objectId: '4047d2e25211d87922b6650233bd0503a6734279',\n *   version: 1,\n *   digest: 'bCiANCht4O9MEUhuYjdRCqRPZjr2rJ8MfqNiwyhmRgA='\n * } } };\n * ```\n *\n * For `Pure` arguments BCS is required. You must encode the values with BCS according\n * to the type required by the called function. Pure accepts only serialized values\n */\nexport type CallArg = PureArg | { Object: ObjectArg };\n\n/**\n * Kind of a TypeTag which is represented by a Move type identifier.\n */\nexport type StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: TypeTag[];\n};\n\n/**\n * Sui TypeTag object. A decoupled `0x...::module::Type<???>` parameter.\n */\nexport type TypeTag =\n\t| { bool: null | true }\n\t| { u8: null | true }\n\t| { u64: null | true }\n\t| { u128: null | true }\n\t| { address: null | true }\n\t| { signer: null | true }\n\t| { vector: TypeTag }\n\t| { struct: StructTag }\n\t| { u16: null | true }\n\t| { u32: null | true }\n\t| { u256: null | true };\n\n// ========== TransactionData ===========\n\n/**\n * The GasData to be used in the transaction.\n */\nexport type GasData = {\n\tpayment: SuiObjectRefType[];\n\towner: string; // Gas Object's owner\n\tprice: number;\n\tbudget: number;\n};\n\n/**\n * TransactionExpiration\n *\n * Indications the expiration time for a transaction.\n */\nexport type TransactionExpiration = { None: null } | { Epoch: number };\n\nconst bcsRegistry = new BcsRegistry({\n\t...getSuiMoveConfig(),\n\ttypes: {\n\t\tenums: {\n\t\t\t'Option<T>': {\n\t\t\t\tNone: null,\n\t\t\t\tSome: 'T',\n\t\t\t},\n\t\t},\n\t},\n});\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\n/**\n * Wrapper around Enum, which transforms any `T` into an object with `kind` property:\n * @example\n * ```\n * let bcsEnum = { TransferObjects: { objects: [], address: ... } }\n * // becomes\n * let translatedEnum = { kind: 'TransferObjects', objects: [], address: ... };\n * ```\n */\nfunction enumKind<T extends object, Input extends object>(type: BcsType<T, Input>) {\n\ttype Merge<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\n\ttype EnumKindTransform<T> = T extends infer U\n\t\t? Merge<(U[keyof U] extends null | boolean ? object : U[keyof U]) & { kind: keyof U }>\n\t\t: never;\n\n\treturn type.transform({\n\t\tinput: (val: EnumKindTransform<Input>) =>\n\t\t\t({\n\t\t\t\t[val.kind]: val,\n\t\t\t}) as Input,\n\t\toutput: (val) => {\n\t\t\tconst key = Object.keys(val)[0] as keyof T;\n\n\t\t\treturn { kind: key, ...val[key] } as EnumKindTransform<T>;\n\t\t},\n\t});\n}\n\nconst Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHEX(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHEX(val)),\n});\n\nconst ObjectDigest = bcs.vector(bcs.u8()).transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromB58(value),\n\toutput: (value) => toB58(new Uint8Array(value)),\n});\n\nconst SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nconst SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nconst ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwned: SuiObjectRef,\n\tShared: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nconst CallArg = bcs.enum('CallArg', {\n\tPure: bcs.vector(bcs.u8()),\n\tObject: ObjectArg,\n\tObjVec: bcs.vector(ObjectArg),\n});\n\nconst TypeTag: BcsType<TypeTag> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => TypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as never;\n\nconst Argument = enumKind(\n\tbcs.enum('Argument', {\n\t\tGasCoin: null,\n\t\tInput: bcs.struct('Input', { index: bcs.u16() }),\n\t\tResult: bcs.struct('Result', { index: bcs.u16() }),\n\t\tNestedResult: bcs.struct('NestedResult', { index: bcs.u16(), resultIndex: bcs.u16() }),\n\t}),\n);\n\n/** Custom serializer for decoding package, module, function easier */\nconst ProgrammableMoveCall = bcs\n\t.struct('ProgrammableMoveCall', {\n\t\tpackage: Address,\n\t\tmodule: bcs.string(),\n\t\tfunction: bcs.string(),\n\t\ttype_arguments: bcs.vector(TypeTag),\n\t\targuments: bcs.vector(Argument),\n\t})\n\t.transform({\n\t\tinput: (data: MoveCallTransaction) => {\n\t\t\tconst [pkg, module, fun] = data.target.split('::');\n\t\t\tconst type_arguments = data.typeArguments.map((tag) =>\n\t\t\t\tTypeTagSerializer.parseFromStr(tag, true),\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tpackage: normalizeSuiAddress(pkg),\n\t\t\t\tmodule,\n\t\t\t\tfunction: fun,\n\t\t\t\ttype_arguments,\n\t\t\t\targuments: data.arguments,\n\t\t\t};\n\t\t},\n\t\toutput: (data) => {\n\t\t\treturn {\n\t\t\t\ttarget: [data.package, data.module, data.function].join(\n\t\t\t\t\t'::',\n\t\t\t\t) as `${string}::${string}::${string}`,\n\t\t\t\targuments: data.arguments,\n\t\t\t\ttypeArguments: data.type_arguments.map(TypeTagSerializer.tagToString),\n\t\t\t};\n\t\t},\n\t});\n\nconst Transaction = enumKind(\n\tbcs.enum('Transaction', {\n\t\t/**\n\t\t * A Move Call - any public Move function can be called via\n\t\t * this transaction. The results can be used that instant to pass\n\t\t * into the next transaction.\n\t\t */\n\t\tMoveCall: ProgrammableMoveCall,\n\t\t/**\n\t\t * Transfer vector of objects to a receiver.\n\t\t */\n\t\tTransferObjects: bcs.struct('TransferObjects', {\n\t\t\tobjects: bcs.vector(Argument),\n\t\t\taddress: Argument,\n\t\t}),\n\t\t/**\n\t\t * Split `amount` from a `coin`.\n\t\t */\n\t\tSplitCoins: bcs.struct('SplitCoins', { coin: Argument, amounts: bcs.vector(Argument) }),\n\t\t/**\n\t\t * Merge Vector of Coins (`sources`) into a `destination`.\n\t\t */\n\t\tMergeCoins: bcs.struct('MergeCoins', { destination: Argument, sources: bcs.vector(Argument) }),\n\t\t/**\n\t\t * Publish a Move module.\n\t\t */\n\t\tPublish: bcs.struct('Publish', {\n\t\t\tmodules: bcs.vector(bcs.vector(bcs.u8())),\n\t\t\tdependencies: bcs.vector(Address),\n\t\t}),\n\t\t/**\n\t\t * Build a vector of objects using the input arguments.\n\t\t * It is impossible to construct a `vector<T: key>` otherwise,\n\t\t * so this call serves a utility function.\n\t\t */\n\t\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\t\ttype: optionEnum(TypeTag),\n\t\t\tobjects: bcs.vector(Argument),\n\t\t}),\n\t\t/**  */\n\t\tUpgrade: bcs.struct('Upgrade', {\n\t\t\tmodules: bcs.vector(bcs.vector(bcs.u8())),\n\t\t\tdependencies: bcs.vector(Address),\n\t\t\tpackageId: Address,\n\t\t\tticket: Argument,\n\t\t}),\n\t}),\n);\n\nconst ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\ttransactions: bcs.vector(Transaction),\n});\n\nconst TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nconst TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nconst StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(TypeTag),\n});\n\nconst GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nconst TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nconst TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\n// Signed transaction data needed to generate transaction digest.\nconst SenderSignedData = bcs.struct('SenderSignedData', {\n\tdata: TransactionData,\n\ttxSignatures: bcs.vector(bcs.vector(bcs.u8())),\n});\n\nconst CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.fixedArray(64, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(64, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(64, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nconst PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.fixedArray(32, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(33, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(33, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nconst MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nconst MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nconst MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransaction,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n\n\t// preserve backwards compatibility with old bcs export\n\tser: bcsRegistry.ser.bind(bcsRegistry),\n\tde: bcsRegistry.de.bind(bcsRegistry),\n\tgetTypeInterface: bcsRegistry.getTypeInterface.bind(bcsRegistry),\n\thasType: bcsRegistry.hasType.bind(bcsRegistry),\n\tparseTypeName: bcsRegistry.parseTypeName.bind(bcsRegistry),\n\tregisterAddressType: bcsRegistry.registerAddressType.bind(bcsRegistry),\n\tregisterAlias: bcsRegistry.registerAlias.bind(bcsRegistry),\n\tregisterBcsType: bcsRegistry.registerBcsType.bind(bcsRegistry),\n\tregisterEnumType: bcsRegistry.registerEnumType.bind(bcsRegistry),\n\tregisterStructType: bcsRegistry.registerStructType.bind(bcsRegistry),\n\tregisterType: bcsRegistry.registerType.bind(bcsRegistry),\n\ttypes: bcsRegistry.types,\n};\n\nbcsRegistry.registerBcsType('utf8string', () => bcs.string({ name: 'utf8string' }));\nbcsRegistry.registerBcsType('unsafe_u64', () => unsafe_u64());\nbcsRegistry.registerBcsType('enumKind', (T) => enumKind(T));\n\n[\n\tAddress,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransaction,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n].forEach((type) => {\n\tbcsRegistry.registerBcsType(type.name, () => type);\n});\n\nexport { suiBcs as bcs, bcsRegistry };\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Infer } from 'superstruct';\nimport {\n\tarray,\n\tboolean,\n\tdefine,\n\tis,\n\tliteral,\n\tnumber,\n\tobject,\n\trecord,\n\tstring,\n\ttuple,\n\tunion,\n} from 'superstruct';\n\nexport type SuiMoveFunctionArgTypesResponse = Infer<typeof SuiMoveFunctionArgType>[];\n\nexport const SuiMoveFunctionArgType = union([string(), object({ Object: string() })]);\n\nexport const SuiMoveFunctionArgTypes = array(SuiMoveFunctionArgType);\nexport type SuiMoveFunctionArgTypes = Infer<typeof SuiMoveFunctionArgTypes>;\n\nexport const SuiMoveModuleId = object({\n\taddress: string(),\n\tname: string(),\n});\nexport type SuiMoveModuleId = Infer<typeof SuiMoveModuleId>;\n\nexport const SuiMoveVisibility = union([literal('Private'), literal('Public'), literal('Friend')]);\nexport type SuiMoveVisibility = Infer<typeof SuiMoveVisibility>;\n\nexport const SuiMoveAbilitySet = object({\n\tabilities: array(string()),\n});\nexport type SuiMoveAbilitySet = Infer<typeof SuiMoveAbilitySet>;\n\nexport const SuiMoveStructTypeParameter = object({\n\tconstraints: SuiMoveAbilitySet,\n\tisPhantom: boolean(),\n});\nexport type SuiMoveStructTypeParameter = Infer<typeof SuiMoveStructTypeParameter>;\n\nexport const SuiMoveNormalizedTypeParameterType = object({\n\tTypeParameter: number(),\n});\nexport type SuiMoveNormalizedTypeParameterType = Infer<typeof SuiMoveNormalizedTypeParameterType>;\n\nexport type SuiMoveNormalizedType =\n\t| string\n\t| SuiMoveNormalizedTypeParameterType\n\t| { Reference: SuiMoveNormalizedType }\n\t| { MutableReference: SuiMoveNormalizedType }\n\t| { Vector: SuiMoveNormalizedType }\n\t| SuiMoveNormalizedStructType;\n\nexport const MoveCallMetric = tuple([\n\tobject({\n\t\tmodule: string(),\n\t\tpackage: string(),\n\t\tfunction: string(),\n\t}),\n\tstring(),\n]);\n\nexport type MoveCallMetric = Infer<typeof MoveCallMetric>;\n\nexport const MoveCallMetrics = object({\n\trank3Days: array(MoveCallMetric),\n\trank7Days: array(MoveCallMetric),\n\trank30Days: array(MoveCallMetric),\n});\n\nexport type MoveCallMetrics = Infer<typeof MoveCallMetrics>;\n\nfunction isSuiMoveNormalizedType(value: unknown): value is SuiMoveNormalizedType {\n\tif (!value) return false;\n\tif (typeof value === 'string') return true;\n\tif (is(value, SuiMoveNormalizedTypeParameterType)) return true;\n\tif (isSuiMoveNormalizedStructType(value)) return true;\n\tif (typeof value !== 'object') return false;\n\n\tconst valueProperties = value as Record<string, unknown>;\n\tif (is(valueProperties.Reference, SuiMoveNormalizedType)) return true;\n\tif (is(valueProperties.MutableReference, SuiMoveNormalizedType)) return true;\n\tif (is(valueProperties.Vector, SuiMoveNormalizedType)) return true;\n\treturn false;\n}\n\nexport const SuiMoveNormalizedType = define<SuiMoveNormalizedType>(\n\t'SuiMoveNormalizedType',\n\tisSuiMoveNormalizedType,\n);\n\nexport type SuiMoveNormalizedStructType = {\n\tStruct: {\n\t\taddress: string;\n\t\tmodule: string;\n\t\tname: string;\n\t\ttypeArguments: SuiMoveNormalizedType[];\n\t};\n};\n\nfunction isSuiMoveNormalizedStructType(value: unknown): value is SuiMoveNormalizedStructType {\n\tif (!value || typeof value !== 'object') return false;\n\n\tconst valueProperties = value as Record<string, unknown>;\n\tif (!valueProperties.Struct || typeof valueProperties.Struct !== 'object') return false;\n\n\tconst structProperties = valueProperties.Struct as Record<string, unknown>;\n\tif (\n\t\ttypeof structProperties.address !== 'string' ||\n\t\ttypeof structProperties.module !== 'string' ||\n\t\ttypeof structProperties.name !== 'string' ||\n\t\t!Array.isArray(structProperties.typeArguments) ||\n\t\t!structProperties.typeArguments.every((value) => isSuiMoveNormalizedType(value))\n\t) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// NOTE: This type is recursive, so we need to manually implement it:\nexport const SuiMoveNormalizedStructType = define<SuiMoveNormalizedStructType>(\n\t'SuiMoveNormalizedStructType',\n\tisSuiMoveNormalizedStructType,\n);\n\nexport const SuiMoveNormalizedFunction = object({\n\tvisibility: SuiMoveVisibility,\n\tisEntry: boolean(),\n\ttypeParameters: array(SuiMoveAbilitySet),\n\tparameters: array(SuiMoveNormalizedType),\n\treturn: array(SuiMoveNormalizedType),\n});\nexport type SuiMoveNormalizedFunction = Infer<typeof SuiMoveNormalizedFunction>;\n\nexport const SuiMoveNormalizedField = object({\n\tname: string(),\n\ttype: SuiMoveNormalizedType,\n});\nexport type SuiMoveNormalizedField = Infer<typeof SuiMoveNormalizedField>;\n\nexport const SuiMoveNormalizedStruct = object({\n\tabilities: SuiMoveAbilitySet,\n\ttypeParameters: array(SuiMoveStructTypeParameter),\n\tfields: array(SuiMoveNormalizedField),\n});\nexport type SuiMoveNormalizedStruct = Infer<typeof SuiMoveNormalizedStruct>;\n\nexport const SuiMoveNormalizedModule = object({\n\tfileFormatVersion: number(),\n\taddress: string(),\n\tname: string(),\n\tfriends: array(SuiMoveModuleId),\n\tstructs: record(string(), SuiMoveNormalizedStruct),\n\texposedFunctions: record(string(), SuiMoveNormalizedFunction),\n});\nexport type SuiMoveNormalizedModule = Infer<typeof SuiMoveNormalizedModule>;\n\nexport const SuiMoveNormalizedModules = record(string(), SuiMoveNormalizedModule);\nexport type SuiMoveNormalizedModules = Infer<typeof SuiMoveNormalizedModules>;\n\nexport function extractMutableReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'MutableReference' in normalizedType\n\t\t? normalizedType.MutableReference\n\t\t: undefined;\n}\n\nexport function extractReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'Reference' in normalizedType\n\t\t? normalizedType.Reference\n\t\t: undefined;\n}\n\nexport function extractStructTag(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedStructType | undefined {\n\tif (typeof normalizedType === 'object' && 'Struct' in normalizedType) {\n\t\treturn normalizedType;\n\t}\n\n\tconst ref = extractReference(normalizedType);\n\tconst mutRef = extractMutableReference(normalizedType);\n\n\tif (typeof ref === 'object' && 'Struct' in ref) {\n\t\treturn ref;\n\t}\n\n\tif (typeof mutRef === 'object' && 'Struct' in mutRef) {\n\t\treturn mutRef;\n\t}\n\treturn undefined;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Infer } from 'superstruct';\nimport { boolean, define, literal, nullable, object, record, string, union } from 'superstruct';\n\nimport type { CallArg } from '../bcs/index.js';\n\nexport const ObjectOwner = union([\n\tobject({\n\t\tAddressOwner: string(),\n\t}),\n\tobject({\n\t\tObjectOwner: string(),\n\t}),\n\tobject({\n\t\tShared: object({\n\t\t\tinitial_shared_version: nullable(string()),\n\t\t}),\n\t}),\n\tliteral('Immutable'),\n]);\nexport type ObjectOwner = Infer<typeof ObjectOwner>;\n\nexport type SuiJsonValue = boolean | number | string | CallArg | Array<SuiJsonValue>;\nexport const SuiJsonValue = define<SuiJsonValue>('SuiJsonValue', () => true);\n\nconst ProtocolConfigValue = union([\n\tobject({ u32: string() }),\n\tobject({ u64: string() }),\n\tobject({ f64: string() }),\n]);\ntype ProtocolConfigValue = Infer<typeof ProtocolConfigValue>;\n\nexport const ProtocolConfig = object({\n\tattributes: record(string(), nullable(ProtocolConfigValue)),\n\tfeatureFlags: record(string(), boolean()),\n\tmaxSupportedProtocolVersion: string(),\n\tminSupportedProtocolVersion: string(),\n\tprotocolVersion: string(),\n});\nexport type ProtocolConfig = Infer<typeof ProtocolConfig>;\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Infer } from 'superstruct';\nimport {\n\tany,\n\tarray,\n\tassign,\n\tbigint,\n\tboolean,\n\tis,\n\tliteral,\n\tnullable,\n\tnumber,\n\tobject,\n\toptional,\n\trecord,\n\tstring,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'superstruct';\n\nimport { ObjectOwner } from './common.js';\n\nexport const ObjectType = union([string(), literal('package')]);\nexport type ObjectType = Infer<typeof ObjectType>;\n\nexport const SuiObjectRef = object({\n\t/** Base64 string representing the object digest */\n\tdigest: string(),\n\t/** Hex code as string representing the object id */\n\tobjectId: string(),\n\t/** Object version */\n\tversion: union([number(), string(), bigint()]),\n});\nexport type SuiObjectRef = Infer<typeof SuiObjectRef>;\n\nexport const OwnedObjectRef = object({\n\towner: ObjectOwner,\n\treference: SuiObjectRef,\n});\nexport type OwnedObjectRef = Infer<typeof OwnedObjectRef>;\nexport const TransactionEffectsModifiedAtVersions = object({\n\tobjectId: string(),\n\tsequenceNumber: string(),\n});\n\nexport const SuiGasData = object({\n\tpayment: array(SuiObjectRef),\n\t/** Gas Object's owner */\n\towner: string(),\n\tprice: string(),\n\tbudget: string(),\n});\nexport type SuiGasData = Infer<typeof SuiGasData>;\n\nexport const SuiObjectInfo = assign(\n\tSuiObjectRef,\n\tobject({\n\t\ttype: string(),\n\t\towner: ObjectOwner,\n\t\tpreviousTransaction: string(),\n\t}),\n);\nexport type SuiObjectInfo = Infer<typeof SuiObjectInfo>;\n\nexport const ObjectContentFields = record(string(), any());\nexport type ObjectContentFields = Infer<typeof ObjectContentFields>;\n\nexport const MovePackageContent = record(string(), unknown());\nexport type MovePackageContent = Infer<typeof MovePackageContent>;\n\nexport const SuiMoveObject = object({\n\t/** Move type (e.g., \"0x2::coin::Coin<0x2::sui::SUI>\") */\n\ttype: string(),\n\t/** Fields and values stored inside the Move object */\n\tfields: ObjectContentFields,\n\thasPublicTransfer: boolean(),\n});\nexport type SuiMoveObject = Infer<typeof SuiMoveObject>;\n\nexport const SuiMovePackage = object({\n\t/** A mapping from module name to disassembled Move bytecode */\n\tdisassembled: MovePackageContent,\n});\nexport type SuiMovePackage = Infer<typeof SuiMovePackage>;\n\nexport const SuiParsedData = union([\n\tassign(SuiMoveObject, object({ dataType: literal('moveObject') })),\n\tassign(SuiMovePackage, object({ dataType: literal('package') })),\n]);\nexport type SuiParsedData = Infer<typeof SuiParsedData>;\n\nexport const SuiRawMoveObject = object({\n\t/** Move type (e.g., \"0x2::coin::Coin<0x2::sui::SUI>\") */\n\ttype: string(),\n\thasPublicTransfer: boolean(),\n\tversion: string(),\n\tbcsBytes: string(),\n});\nexport type SuiRawMoveObject = Infer<typeof SuiRawMoveObject>;\n\nexport const SuiRawMovePackage = object({\n\tid: string(),\n\t/** A mapping from module name to Move bytecode enocded in base64*/\n\tmoduleMap: record(string(), string()),\n});\nexport type SuiRawMovePackage = Infer<typeof SuiRawMovePackage>;\n\n// TODO(chris): consolidate SuiRawParsedData and SuiRawObject using generics\nexport const SuiRawData = union([\n\tassign(SuiRawMoveObject, object({ dataType: literal('moveObject') })),\n\tassign(SuiRawMovePackage, object({ dataType: literal('package') })),\n]);\nexport type SuiRawData = Infer<typeof SuiRawData>;\n\nexport const SUI_DECIMALS = 9;\n\nexport const MIST_PER_SUI = BigInt(1000000000);\n\nexport const SuiObjectResponseError = object({\n\tcode: string(),\n\terror: optional(string()),\n\tobject_id: optional(string()),\n\tparent_object_id: optional(string()),\n\tversion: optional(string()),\n\tdigest: optional(string()),\n});\nexport type SuiObjectResponseError = Infer<typeof SuiObjectResponseError>;\nexport const DisplayFieldsResponse = object({\n\tdata: nullable(optional(record(string(), string()))),\n\terror: nullable(optional(SuiObjectResponseError)),\n});\nexport type DisplayFieldsResponse = Infer<typeof DisplayFieldsResponse>;\n// TODO: remove after all envs support the new DisplayFieldsResponse;\nexport const DisplayFieldsBackwardCompatibleResponse = union([\n\tDisplayFieldsResponse,\n\toptional(record(string(), string())),\n]);\nexport type DisplayFieldsBackwardCompatibleResponse = Infer<\n\ttypeof DisplayFieldsBackwardCompatibleResponse\n>;\n\nexport const SuiObjectData = object({\n\tobjectId: string(),\n\tversion: string(),\n\tdigest: string(),\n\t/**\n\t * Type of the object, default to be undefined unless SuiObjectDataOptions.showType is set to true\n\t */\n\ttype: nullable(optional(string())),\n\t/**\n\t * Move object content or package content, default to be undefined unless SuiObjectDataOptions.showContent is set to true\n\t */\n\tcontent: nullable(optional(SuiParsedData)),\n\t/**\n\t * Move object content or package content in BCS bytes, default to be undefined unless SuiObjectDataOptions.showBcs is set to true\n\t */\n\tbcs: nullable(optional(SuiRawData)),\n\t/**\n\t * The owner of this object. Default to be undefined unless SuiObjectDataOptions.showOwner is set to true\n\t */\n\towner: nullable(optional(ObjectOwner)),\n\t/**\n\t * The digest of the transaction that created or last mutated this object.\n\t * Default to be undefined unless SuiObjectDataOptions.showPreviousTransaction is set to true\n\t */\n\tpreviousTransaction: nullable(optional(string())),\n\t/**\n\t * The amount of SUI we would rebate if this object gets deleted.\n\t * This number is re-calculated each time the object is mutated based on\n\t * the present storage gas price.\n\t * Default to be undefined unless SuiObjectDataOptions.showStorageRebate is set to true\n\t */\n\tstorageRebate: nullable(optional(string())),\n\t/**\n\t * Display metadata for this object, default to be undefined unless SuiObjectDataOptions.showDisplay is set to true\n\t * This can also be None if the struct type does not have Display defined\n\t * See more details in https://forums.sui.io/t/nft-object-display-proposal/4872\n\t */\n\tdisplay: nullable(optional(DisplayFieldsBackwardCompatibleResponse)),\n});\nexport type SuiObjectData = Infer<typeof SuiObjectData>;\n\n/**\n * Config for fetching object data\n */\nexport const SuiObjectDataOptions = object({\n\t/* Whether to fetch the object type, default to be true */\n\tshowType: nullable(optional(boolean())),\n\t/* Whether to fetch the object content, default to be false */\n\tshowContent: nullable(optional(boolean())),\n\t/* Whether to fetch the object content in BCS bytes, default to be false */\n\tshowBcs: nullable(optional(boolean())),\n\t/* Whether to fetch the object owner, default to be false */\n\tshowOwner: nullable(optional(boolean())),\n\t/* Whether to fetch the previous transaction digest, default to be false */\n\tshowPreviousTransaction: nullable(optional(boolean())),\n\t/* Whether to fetch the storage rebate, default to be false */\n\tshowStorageRebate: nullable(optional(boolean())),\n\t/* Whether to fetch the display metadata, default to be false */\n\tshowDisplay: nullable(optional(boolean())),\n});\nexport type SuiObjectDataOptions = Infer<typeof SuiObjectDataOptions>;\n\nexport const ObjectStatus = union([literal('Exists'), literal('notExists'), literal('Deleted')]);\nexport type ObjectStatus = Infer<typeof ObjectStatus>;\n\nexport const GetOwnedObjectsResponse = array(SuiObjectInfo);\nexport type GetOwnedObjectsResponse = Infer<typeof GetOwnedObjectsResponse>;\n\nexport const SuiObjectResponse = object({\n\tdata: nullable(optional(SuiObjectData)),\n\terror: nullable(optional(SuiObjectResponseError)),\n});\nexport type SuiObjectResponse = Infer<typeof SuiObjectResponse>;\n\nexport type Order = 'ascending' | 'descending';\n\n/* -------------------------------------------------------------------------- */\n/*                              Helper functions                              */\n/* -------------------------------------------------------------------------- */\n\n/* -------------------------- SuiObjectResponse ------------------------- */\n\nexport function getSuiObjectData(resp: SuiObjectResponse): SuiObjectData | null | undefined {\n\treturn resp.data;\n}\n\nexport function getObjectDeletedResponse(resp: SuiObjectResponse): SuiObjectRef | undefined {\n\tif (\n\t\tresp.error &&\n\t\t'object_id' in resp.error &&\n\t\t'version' in resp.error &&\n\t\t'digest' in resp.error\n\t) {\n\t\tconst error = resp.error as SuiObjectResponseError;\n\t\treturn {\n\t\t\tobjectId: error.object_id,\n\t\t\tversion: error.version,\n\t\t\tdigest: error.digest,\n\t\t} as SuiObjectRef;\n\t}\n\n\treturn undefined;\n}\n\nexport function getObjectNotExistsResponse(resp: SuiObjectResponse): string | undefined {\n\tif (\n\t\tresp.error &&\n\t\t'object_id' in resp.error &&\n\t\t!('version' in resp.error) &&\n\t\t!('digest' in resp.error)\n\t) {\n\t\treturn (resp.error as SuiObjectResponseError).object_id as string;\n\t}\n\n\treturn undefined;\n}\n\nexport function getObjectReference(\n\tresp: SuiObjectResponse | OwnedObjectRef,\n): SuiObjectRef | undefined {\n\tif ('reference' in resp) {\n\t\treturn resp.reference;\n\t}\n\tconst exists = getSuiObjectData(resp);\n\tif (exists) {\n\t\treturn {\n\t\t\tobjectId: exists.objectId,\n\t\t\tversion: exists.version,\n\t\t\tdigest: exists.digest,\n\t\t};\n\t}\n\treturn getObjectDeletedResponse(resp);\n}\n\n/* ------------------------------ SuiObjectRef ------------------------------ */\n\nexport function getObjectId(data: SuiObjectResponse | SuiObjectRef | OwnedObjectRef): string {\n\tif ('objectId' in data) {\n\t\treturn data.objectId;\n\t}\n\treturn (\n\t\tgetObjectReference(data)?.objectId ?? getObjectNotExistsResponse(data as SuiObjectResponse)!\n\t);\n}\n\nexport function getObjectVersion(\n\tdata: SuiObjectResponse | SuiObjectRef | SuiObjectData,\n): string | number | bigint | undefined {\n\tif ('version' in data) {\n\t\treturn data.version;\n\t}\n\treturn getObjectReference(data)?.version;\n}\n\n/* -------------------------------- SuiObject ------------------------------- */\n\nexport function isSuiObjectResponse(\n\tresp: SuiObjectResponse | SuiObjectData,\n): resp is SuiObjectResponse {\n\treturn (resp as SuiObjectResponse).data !== undefined;\n}\n\n/**\n * Deriving the object type from the object response\n * @returns 'package' if the object is a package, move object type(e.g., 0x2::coin::Coin<0x2::sui::SUI>)\n * if the object is a move object\n */\nexport function getObjectType(\n\tresp: SuiObjectResponse | SuiObjectData,\n): ObjectType | null | undefined {\n\tconst data = isSuiObjectResponse(resp) ? resp.data : resp;\n\n\tif (!data?.type && 'data' in resp) {\n\t\tif (data?.content?.dataType === 'package') {\n\t\t\treturn 'package';\n\t\t}\n\t\treturn getMoveObjectType(resp);\n\t}\n\treturn data?.type;\n}\n\nexport function getObjectPreviousTransactionDigest(\n\tresp: SuiObjectResponse,\n): string | null | undefined {\n\treturn getSuiObjectData(resp)?.previousTransaction;\n}\n\nexport function getObjectOwner(\n\tresp: SuiObjectResponse | ObjectOwner,\n): ObjectOwner | null | undefined {\n\tif (is(resp, ObjectOwner)) {\n\t\treturn resp;\n\t}\n\treturn getSuiObjectData(resp)?.owner;\n}\n\nexport function getObjectDisplay(resp: SuiObjectResponse): DisplayFieldsResponse {\n\tconst display = getSuiObjectData(resp)?.display;\n\tif (!display) {\n\t\treturn { data: null, error: null };\n\t}\n\tif (is(display, DisplayFieldsResponse)) {\n\t\treturn display;\n\t}\n\treturn {\n\t\tdata: display,\n\t\terror: null,\n\t};\n}\n\nexport function getSharedObjectInitialVersion(\n\tresp: SuiObjectResponse | ObjectOwner,\n): string | null | undefined {\n\tconst owner = getObjectOwner(resp);\n\tif (owner && typeof owner === 'object' && 'Shared' in owner) {\n\t\treturn owner.Shared.initial_shared_version;\n\t} else {\n\t\treturn undefined;\n\t}\n}\n\nexport function isSharedObject(resp: SuiObjectResponse | ObjectOwner): boolean {\n\tconst owner = getObjectOwner(resp);\n\treturn !!owner && typeof owner === 'object' && 'Shared' in owner;\n}\n\nexport function isImmutableObject(resp: SuiObjectResponse | ObjectOwner): boolean {\n\tconst owner = getObjectOwner(resp);\n\treturn owner === 'Immutable';\n}\n\nexport function getMoveObjectType(resp: SuiObjectResponse): string | undefined {\n\treturn getMoveObject(resp)?.type;\n}\n\nexport function getObjectFields(\n\tresp: SuiObjectResponse | SuiMoveObject | SuiObjectData,\n): ObjectContentFields | undefined {\n\tif ('fields' in resp) {\n\t\treturn resp.fields;\n\t}\n\treturn getMoveObject(resp)?.fields;\n}\n\nexport interface SuiObjectDataWithContent extends SuiObjectData {\n\tcontent: SuiParsedData;\n}\n\nfunction isSuiObjectDataWithContent(data: SuiObjectData): data is SuiObjectDataWithContent {\n\treturn data.content !== undefined;\n}\n\nexport function getMoveObject(data: SuiObjectResponse | SuiObjectData): SuiMoveObject | undefined {\n\tconst suiObject = 'data' in data ? getSuiObjectData(data) : (data as SuiObjectData);\n\n\tif (\n\t\t!suiObject ||\n\t\t!isSuiObjectDataWithContent(suiObject) ||\n\t\tsuiObject.content.dataType !== 'moveObject'\n\t) {\n\t\treturn undefined;\n\t}\n\n\treturn suiObject.content as SuiMoveObject;\n}\n\nexport function hasPublicTransfer(data: SuiObjectResponse | SuiObjectData): boolean {\n\treturn getMoveObject(data)?.hasPublicTransfer ?? false;\n}\n\nexport function getMovePackageContent(\n\tdata: SuiObjectResponse | SuiMovePackage,\n): MovePackageContent | undefined {\n\tif ('disassembled' in data) {\n\t\treturn data.disassembled;\n\t}\n\tconst suiObject = getSuiObjectData(data);\n\tif (suiObject?.content?.dataType !== 'package') {\n\t\treturn undefined;\n\t}\n\treturn (suiObject.content as SuiMovePackage).disassembled;\n}\n\nexport const CheckpointedObjectId = object({\n\tobjectId: string(),\n\tatCheckpoint: optional(number()),\n});\nexport type CheckpointedObjectId = Infer<typeof CheckpointedObjectId>;\n\nexport const PaginatedObjectsResponse = object({\n\tdata: array(SuiObjectResponse),\n\tnextCursor: optional(nullable(string())),\n\thasNextPage: boolean(),\n});\nexport type PaginatedObjectsResponse = Infer<typeof PaginatedObjectsResponse>;\n\n// mirrors sui_json_rpc_types:: SuiObjectDataFilter\nexport type SuiObjectDataFilter =\n\t| { MatchAll: SuiObjectDataFilter[] }\n\t| { MatchAny: SuiObjectDataFilter[] }\n\t| { MatchNone: SuiObjectDataFilter[] }\n\t| { Package: string }\n\t| { MoveModule: { package: string; module: string } }\n\t| { StructType: string }\n\t| { AddressOwner: string }\n\t| { ObjectOwner: string }\n\t| { ObjectId: string }\n\t| { ObjectIds: string[] }\n\t| { Version: string };\n\nexport type SuiObjectResponseQuery = {\n\tfilter?: SuiObjectDataFilter;\n\toptions?: SuiObjectDataOptions;\n};\n\nexport const ObjectRead = union([\n\tobject({\n\t\tdetails: SuiObjectData,\n\t\tstatus: literal('VersionFound'),\n\t}),\n\tobject({\n\t\tdetails: string(),\n\t\tstatus: literal('ObjectNotExists'),\n\t}),\n\tobject({\n\t\tdetails: SuiObjectRef,\n\t\tstatus: literal('ObjectDeleted'),\n\t}),\n\tobject({\n\t\tdetails: tuple([string(), number()]),\n\t\tstatus: literal('VersionNotFound'),\n\t}),\n\tobject({\n\t\tdetails: object({\n\t\t\tasked_version: number(),\n\t\t\tlatest_version: number(),\n\t\t\tobject_id: string(),\n\t\t}),\n\t\tstatus: literal('VersionTooHigh'),\n\t}),\n]);\nexport type ObjectRead = Infer<typeof ObjectRead>;\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { formatAddress, formatDigest } from './format.js';\nimport {\n\tisValidSuiAddress,\n\tisValidSuiObjectId,\n\tisValidTransactionDigest,\n\tnormalizeStructTag,\n\tnormalizeSuiAddress,\n\tnormalizeSuiObjectId,\n\tparseStructTag,\n\tSUI_ADDRESS_LENGTH,\n} from './sui-types.js';\n\nexport { fromB64, toB64, fromHEX, toHEX } from '@mysten/bcs';\nexport { is, assert } from 'superstruct';\n\nexport {\n\tformatAddress,\n\tformatDigest,\n\tisValidSuiAddress,\n\tisValidSuiObjectId,\n\tisValidTransactionDigest,\n\tnormalizeStructTag,\n\tnormalizeSuiAddress,\n\tnormalizeSuiObjectId,\n\tparseStructTag,\n\tSUI_ADDRESS_LENGTH,\n};\n\nexport const SUI_DECIMALS = 9;\nexport const MIST_PER_SUI = BigInt(1000000000);\n\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const SUI_FRAMEWORK_ADDRESS = '0x2';\nexport const SUI_SYSTEM_ADDRESS = '0x3';\nexport const SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId('0x6');\nexport const SUI_SYSTEM_MODULE_NAME = 'sui_system';\nexport const SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nexport const SUI_SYSTEM_STATE_OBJECT_ID: string = normalizeSuiObjectId('0x5');\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { isSerializedBcs } from '@mysten/bcs';\nimport type { Infer } from 'superstruct';\nimport { array, boolean, integer, object, string, union } from 'superstruct';\n\nimport { bcs } from '../bcs/index.js';\nimport type { SharedObjectRef } from '../bcs/index.js';\nimport { SuiObjectRef } from '../types/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\n\nconst ObjectArg = union([\n\tobject({ ImmOrOwned: SuiObjectRef }),\n\tobject({\n\t\tShared: object({\n\t\t\tobjectId: string(),\n\t\t\tinitialSharedVersion: union([integer(), string()]),\n\t\t\tmutable: boolean(),\n\t\t}),\n\t}),\n\tobject({ Receiving: SuiObjectRef }),\n]);\n\nexport const PureCallArg = object({ Pure: array(integer()) });\nexport const ObjectCallArg = object({ Object: ObjectArg });\nexport type PureCallArg = Infer<typeof PureCallArg>;\nexport type ObjectCallArg = Infer<typeof ObjectCallArg>;\n\nexport const BuilderCallArg = union([PureCallArg, ObjectCallArg]);\nexport type BuilderCallArg = Infer<typeof BuilderCallArg>;\n\nfunction Pure(data: Uint8Array | SerializedBcs<any>, type?: string): PureCallArg;\n/** @deprecated pass SerializedBcs values instead */\nfunction Pure(data: unknown, type?: string): PureCallArg;\nfunction Pure(data: unknown, type?: string): PureCallArg {\n\treturn {\n\t\tPure: Array.from(\n\t\t\tdata instanceof Uint8Array\n\t\t\t\t? data\n\t\t\t\t: isSerializedBcs(data)\n\t\t\t\t? data.toBytes()\n\t\t\t\t: // NOTE: We explicitly set this to be growable to infinity, because we have maxSize validation at the builder-level:\n\t\t\t\t  bcs.ser(type!, data, { maxSize: Infinity }).toBytes(),\n\t\t),\n\t};\n}\n\nexport const Inputs = {\n\tPure,\n\tObjectRef({ objectId, digest, version }: SuiObjectRef): ObjectCallArg {\n\t\treturn {\n\t\t\tObject: {\n\t\t\t\tImmOrOwned: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tSharedObjectRef({ objectId, mutable, initialSharedVersion }: SharedObjectRef): ObjectCallArg {\n\t\treturn {\n\t\t\tObject: {\n\t\t\t\tShared: {\n\t\t\t\t\tmutable,\n\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tReceivingRef({ objectId, digest, version }: SuiObjectRef): ObjectCallArg {\n\t\treturn {\n\t\t\tObject: {\n\t\t\t\tReceiving: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n};\n\nexport function getIdFromCallArg(arg: string | ObjectCallArg) {\n\tif (typeof arg === 'string') {\n\t\treturn normalizeSuiAddress(arg);\n\t}\n\tif ('ImmOrOwned' in arg.Object) {\n\t\treturn normalizeSuiAddress(arg.Object.ImmOrOwned.objectId);\n\t}\n\n\tif ('Receiving' in arg.Object) {\n\t\treturn normalizeSuiAddress(arg.Object.Receiving.objectId);\n\t}\n\n\treturn normalizeSuiAddress(arg.Object.Shared.objectId);\n}\n\nexport function getSharedObjectInput(arg: BuilderCallArg): SharedObjectRef | undefined {\n\treturn typeof arg === 'object' && 'Object' in arg && 'Shared' in arg.Object\n\t\t? arg.Object.Shared\n\t\t: undefined;\n}\n\nexport function isSharedObjectInput(arg: BuilderCallArg): boolean {\n\treturn !!getSharedObjectInput(arg);\n}\n\nexport function isMutableSharedObjectInput(arg: BuilderCallArg): boolean {\n\treturn getSharedObjectInput(arg)?.mutable ?? false;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiJsonValue, SuiMoveNormalizedType } from '../client/index.js';\nimport { extractStructTag } from '../types/index.js';\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { isValidSuiAddress } from '../utils/sui-types.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nconst RESOLVED_SUI_ID = {\n\taddress: SUI_FRAMEWORK_ADDRESS,\n\tmodule: OBJECT_MODULE_NAME,\n\tname: ID_STRUCT_NAME,\n};\nconst RESOLVED_ASCII_STR = {\n\taddress: MOVE_STDLIB_ADDRESS,\n\tmodule: STD_ASCII_MODULE_NAME,\n\tname: STD_ASCII_STRUCT_NAME,\n};\nconst RESOLVED_UTF8_STR = {\n\taddress: MOVE_STDLIB_ADDRESS,\n\tmodule: STD_UTF8_MODULE_NAME,\n\tname: STD_UTF8_STRUCT_NAME,\n};\n\nconst RESOLVED_STD_OPTION = {\n\taddress: MOVE_STDLIB_ADDRESS,\n\tmodule: STD_OPTION_MODULE_NAME,\n\tname: STD_OPTION_STRUCT_NAME,\n};\n\nconst isSameStruct = (a: any, b: any) =>\n\ta.address === b.address && a.module === b.module && a.name === b.name;\n\nexport function isTxContext(param: SuiMoveNormalizedType): boolean {\n\tconst struct = extractStructTag(param)?.Struct;\n\treturn (\n\t\tstruct?.address === '0x2' && struct?.module === 'tx_context' && struct?.name === 'TxContext'\n\t);\n}\n\nfunction expectType(typeName: string, argVal?: SuiJsonValue) {\n\tif (typeof argVal === 'undefined') {\n\t\treturn;\n\t}\n\tif (typeof argVal !== typeName) {\n\t\tthrow new Error(`Expect ${argVal} to be ${typeName}, received ${typeof argVal}`);\n\t}\n}\n\nconst allowedTypes = ['Address', 'Bool', 'U8', 'U16', 'U32', 'U64', 'U128', 'U256'];\n\nexport function getPureSerializationType(\n\tnormalizedType: SuiMoveNormalizedType,\n\targVal: SuiJsonValue | undefined,\n): string | undefined {\n\tif (typeof normalizedType === 'string' && allowedTypes.includes(normalizedType)) {\n\t\tif (normalizedType in ['U8', 'U16', 'U32', 'U64', 'U128', 'U256']) {\n\t\t\texpectType('number', argVal);\n\t\t} else if (normalizedType === 'Bool') {\n\t\t\texpectType('boolean', argVal);\n\t\t} else if (normalizedType === 'Address') {\n\t\t\texpectType('string', argVal);\n\t\t\tif (argVal && !isValidSuiAddress(argVal as string)) {\n\t\t\t\tthrow new Error('Invalid Sui Address');\n\t\t\t}\n\t\t}\n\t\treturn normalizedType.toLowerCase();\n\t} else if (typeof normalizedType === 'string') {\n\t\tthrow new Error(`Unknown pure normalized type ${JSON.stringify(normalizedType, null, 2)}`);\n\t}\n\n\tif ('Vector' in normalizedType) {\n\t\tif ((argVal === undefined || typeof argVal === 'string') && normalizedType.Vector === 'U8') {\n\t\t\treturn 'string';\n\t\t}\n\n\t\tif (argVal !== undefined && !Array.isArray(argVal)) {\n\t\t\tthrow new Error(`Expect ${argVal} to be a array, received ${typeof argVal}`);\n\t\t}\n\n\t\tconst innerType = getPureSerializationType(\n\t\t\tnormalizedType.Vector,\n\t\t\t// undefined when argVal is empty\n\t\t\targVal ? argVal[0] : undefined,\n\t\t);\n\n\t\tif (innerType === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn `vector<${innerType}>`;\n\t}\n\n\tif ('Struct' in normalizedType) {\n\t\tif (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {\n\t\t\treturn 'string';\n\t\t} else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {\n\t\t\treturn 'utf8string';\n\t\t} else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {\n\t\t\treturn 'address';\n\t\t} else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {\n\t\t\tconst optionToVec: SuiMoveNormalizedType = {\n\t\t\t\tVector: normalizedType.Struct.typeArguments[0],\n\t\t\t};\n\t\t\treturn getPureSerializationType(optionToVec, argVal);\n\t\t}\n\t}\n\n\treturn undefined;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64 } from '@mysten/bcs';\nimport type { Infer, Struct } from 'superstruct';\nimport {\n\tany,\n\tarray,\n\tassert,\n\tdefine,\n\tinteger,\n\tis,\n\tliteral,\n\tobject,\n\toptional,\n\trecord,\n\tstring,\n\tunion,\n\tunknown,\n} from 'superstruct';\n\nimport type { TypeTag } from '../bcs/index.js';\nimport { bcs } from '../bcs/index.js';\nimport { TypeTagSerializer } from '../bcs/type-tag-serializer.js';\nimport { normalizeSuiObjectId } from '../utils/sui-types.js';\nimport { Inputs } from './Inputs.js';\nimport { create } from './utils.js';\n\nconst option = <T extends Struct<any, any>>(some: T) =>\n\tunion([object({ None: union([literal(true), literal(null)]) }), object({ Some: some })]);\n\nexport const TransactionBlockInput = union([\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: integer(),\n\t\tvalue: optional(any()),\n\t\ttype: optional(literal('object')),\n\t}),\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: integer(),\n\t\tvalue: optional(any()),\n\t\ttype: literal('pure'),\n\t}),\n]);\nexport type TransactionBlockInput = Infer<typeof TransactionBlockInput>;\n\nconst TransactionArgumentTypes = [\n\tTransactionBlockInput,\n\tobject({ kind: literal('GasCoin') }),\n\tobject({ kind: literal('Result'), index: integer() }),\n\tobject({\n\t\tkind: literal('NestedResult'),\n\t\tindex: integer(),\n\t\tresultIndex: integer(),\n\t}),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\nexport type TransactionArgument = Infer<typeof TransactionArgument>;\n\nexport const MoveCallTransaction = object({\n\tkind: literal('MoveCall'),\n\ttarget: define<`${string}::${string}::${string}`>('target', string().validator),\n\ttypeArguments: array(string()),\n\targuments: array(TransactionArgument),\n});\nexport type MoveCallTransaction = Infer<typeof MoveCallTransaction>;\n\nexport const TransferObjectsTransaction = object({\n\tkind: literal('TransferObjects'),\n\tobjects: array(TransactionArgument),\n\taddress: TransactionArgument,\n});\nexport type TransferObjectsTransaction = Infer<typeof TransferObjectsTransaction>;\n\nexport const SplitCoinsTransaction = object({\n\tkind: literal('SplitCoins'),\n\tcoin: TransactionArgument,\n\tamounts: array(TransactionArgument),\n});\nexport type SplitCoinsTransaction = Infer<typeof SplitCoinsTransaction>;\n\nexport const MergeCoinsTransaction = object({\n\tkind: literal('MergeCoins'),\n\tdestination: TransactionArgument,\n\tsources: array(TransactionArgument),\n});\nexport type MergeCoinsTransaction = Infer<typeof MergeCoinsTransaction>;\n\nexport const MakeMoveVecTransaction = object({\n\tkind: literal('MakeMoveVec'),\n\t// TODO: ideally we should use `TypeTag` instead of `record()` here,\n\t// but TypeTag is recursively defined and it's tricky to define a\n\t// recursive struct in superstruct\n\ttype: optional(option(record(string(), unknown()))) as never as Struct<\n\t\t{ Some: TypeTag } | { None: true | null }\n\t>,\n\tobjects: array(TransactionArgument),\n});\nexport type MakeMoveVecTransaction = Infer<typeof MakeMoveVecTransaction>;\n\nexport const PublishTransaction = object({\n\tkind: literal('Publish'),\n\tmodules: array(array(integer())),\n\tdependencies: array(string()),\n});\nexport type PublishTransaction = Infer<typeof PublishTransaction>;\n\n// Keep in sync with constants in\n// crates/sui-framework/packages/sui-framework/sources/package.move\nexport enum UpgradePolicy {\n\tCOMPATIBLE = 0,\n\tADDITIVE = 128,\n\tDEP_ONLY = 192,\n}\n\nexport const UpgradeTransaction = object({\n\tkind: literal('Upgrade'),\n\tmodules: array(array(integer())),\n\tdependencies: array(string()),\n\tpackageId: string(),\n\tticket: TransactionArgument,\n});\nexport type UpgradeTransaction = Infer<typeof UpgradeTransaction>;\n\nconst TransactionTypes = [\n\tMoveCallTransaction,\n\tTransferObjectsTransaction,\n\tSplitCoinsTransaction,\n\tMergeCoinsTransaction,\n\tPublishTransaction,\n\tUpgradeTransaction,\n\tMakeMoveVecTransaction,\n] as const;\n\nexport const TransactionType = union([...TransactionTypes]);\nexport type TransactionType = Infer<typeof TransactionType>;\n\nexport function getTransactionType(data: unknown) {\n\tassert(data, TransactionType);\n\treturn TransactionTypes.find((schema) => is(data, schema as Struct))!;\n}\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Transactions = {\n\tMoveCall(\n\t\tinput: Omit<MoveCallTransaction, 'kind' | 'arguments' | 'typeArguments'> & {\n\t\t\targuments?: TransactionArgument[];\n\t\t\ttypeArguments?: string[];\n\t\t},\n\t): MoveCallTransaction {\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'MoveCall',\n\t\t\t\ttarget: input.target,\n\t\t\t\targuments: input.arguments ?? [],\n\t\t\t\ttypeArguments: input.typeArguments ?? [],\n\t\t\t},\n\t\t\tMoveCallTransaction,\n\t\t);\n\t},\n\tTransferObjects(\n\t\tobjects: TransactionArgument[],\n\t\taddress: TransactionArgument,\n\t): TransferObjectsTransaction {\n\t\tif (address.kind === 'Input' && address.type === 'pure' && typeof address.value !== 'object') {\n\t\t\taddress.value = Inputs.Pure(bcs.Address.serialize(address.value));\n\t\t}\n\n\t\treturn create({ kind: 'TransferObjects', objects, address }, TransferObjectsTransaction);\n\t},\n\tSplitCoins(coin: TransactionArgument, amounts: TransactionArgument[]): SplitCoinsTransaction {\n\t\t// Handle deprecated usage of `Input.Pure(100)`\n\t\tamounts.forEach((input) => {\n\t\t\tif (input.kind === 'Input' && input.type === 'pure' && typeof input.value !== 'object') {\n\t\t\t\tinput.value = Inputs.Pure(bcs.U64.serialize(input.value));\n\t\t\t}\n\t\t});\n\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'SplitCoins',\n\t\t\t\tcoin,\n\t\t\t\tamounts,\n\t\t\t},\n\t\t\tSplitCoinsTransaction,\n\t\t);\n\t},\n\tMergeCoins(\n\t\tdestination: TransactionArgument,\n\t\tsources: TransactionArgument[],\n\t): MergeCoinsTransaction {\n\t\treturn create({ kind: 'MergeCoins', destination, sources }, MergeCoinsTransaction);\n\t},\n\tPublish({\n\t\tmodules,\n\t\tdependencies,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t}): PublishTransaction {\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'Publish',\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? Array.from(fromB64(module)) : module,\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t},\n\t\t\tPublishTransaction,\n\t\t);\n\t},\n\tUpgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackageId: string;\n\t\tticket: TransactionArgument;\n\t}): UpgradeTransaction {\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'Upgrade',\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? Array.from(fromB64(module)) : module,\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t\tpackageId,\n\t\t\t\tticket,\n\t\t\t},\n\t\t\tUpgradeTransaction,\n\t\t);\n\t},\n\tMakeMoveVec({\n\t\ttype,\n\t\tobjects,\n\t}: Omit<MakeMoveVecTransaction, 'kind' | 'type'> & {\n\t\ttype?: string;\n\t}): MakeMoveVecTransaction {\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'MakeMoveVec',\n\t\t\t\ttype: type ? { Some: TypeTagSerializer.parseFromStr(type) } : { None: null },\n\t\t\t\tobjects,\n\t\t\t},\n\t\t\tMakeMoveVecTransaction,\n\t\t);\n\t},\n};\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromB64, isSerializedBcs } from '@mysten/bcs';\nimport { is, mask } from 'superstruct';\n\nimport { bcs } from '../bcs/index.js';\nimport type { ProtocolConfig, SuiClient, SuiMoveNormalizedType } from '../client/index.js';\nimport type { Keypair, SignatureWithBytes } from '../cryptography/index.js';\nimport type { SuiObjectResponse } from '../types/index.js';\nimport {\n\textractMutableReference,\n\textractReference,\n\textractStructTag,\n\tgetObjectReference,\n\tSuiObjectRef,\n} from '../types/index.js';\nimport { SUI_TYPE_ARG } from '../utils/index.js';\nimport { normalizeSuiAddress, normalizeSuiObjectId } from '../utils/sui-types.js';\nimport type { ObjectCallArg } from './Inputs.js';\nimport {\n\tBuilderCallArg,\n\tgetIdFromCallArg,\n\tInputs,\n\tisMutableSharedObjectInput,\n\tPureCallArg,\n} from './Inputs.js';\nimport { createPure } from './pure.js';\nimport { getPureSerializationType, isTxContext } from './serializer.js';\nimport type { TransactionExpiration } from './TransactionBlockData.js';\nimport { TransactionBlockDataBuilder } from './TransactionBlockData.js';\nimport type { MoveCallTransaction, TransactionArgument, TransactionType } from './Transactions.js';\nimport { TransactionBlockInput, Transactions } from './Transactions.js';\nimport { create } from './utils.js';\n\nexport type TransactionObjectArgument = Exclude<\n\tTransactionArgument,\n\t{ kind: 'Input'; type: 'pure' }\n>;\n\nexport type TransactionResult = Extract<TransactionArgument, { kind: 'Result' }> &\n\tExtract<TransactionArgument, { kind: 'NestedResult' }>[];\n\nconst DefaultOfflineLimits = {\n\tmaxPureArgumentSize: 16 * 1024,\n\tmaxTxGas: 50_000_000_000,\n\tmaxGasObjects: 256,\n\tmaxTxSizeBytes: 128 * 1024,\n} satisfies Limits;\n\nfunction createTransactionResult(index: number): TransactionResult {\n\tconst baseResult: TransactionArgument = { kind: 'Result', index };\n\n\tconst nestedResults: TransactionArgument[] = [];\n\tconst nestedResultFor = (resultIndex: number): TransactionArgument =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\tkind: 'NestedResult',\n\t\t\tindex,\n\t\t\tresultIndex,\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nfunction isReceivingType(normalizedType: SuiMoveNormalizedType): boolean {\n\tconst tag = extractStructTag(normalizedType);\n\tif (tag) {\n\t\treturn (\n\t\t\ttag.Struct.address === '0x2' &&\n\t\t\ttag.Struct.module === 'transfer' &&\n\t\t\ttag.Struct.name === 'Receiving'\n\t\t);\n\t}\n\treturn false;\n}\n\nfunction expectClient(options: BuildOptions): SuiClient {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction');\n\nconst LIMITS = {\n\t// The maximum gas that is allowed.\n\tmaxTxGas: 'max_tx_gas',\n\t// The maximum number of gas objects that can be selected for one transaction.\n\tmaxGasObjects: 'max_gas_payment_objects',\n\t// The maximum size (in bytes) that the transaction can be:\n\tmaxTxSizeBytes: 'max_tx_size_bytes',\n\t// The maximum size (in bytes) that pure arguments can be:\n\tmaxPureArgumentSize: 'max_pure_argument_size',\n} as const;\n\ntype Limits = Partial<Record<keyof typeof LIMITS, number>>;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\nconst chunk = <T>(arr: T[], size: number): T[][] =>\n\tArray.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n\t\tarr.slice(i * size, i * size + size),\n\t);\n\ninterface BuildOptions {\n\tclient?: SuiClient;\n\tonlyTransactionKind?: boolean;\n\t/** Define a protocol config to build against, instead of having it fetched from the provider at build time. */\n\tprotocolConfig?: ProtocolConfig;\n\t/** Define limits that are used when building the transaction. In general, we recommend using the protocol configuration instead of defining limits. */\n\tlimits?: Limits;\n}\n\ninterface SignOptions extends BuildOptions {\n\tsigner: Keypair;\n}\n\nexport function isTransactionBlock(obj: unknown): obj is TransactionBlock {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | ObjectCallArg | TransactionObjectArgument;\n\n/**\n * Transaction Builder\n */\nexport class TransactionBlock {\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\ttx.#blockData = TransactionBlockDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t);\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\t// Check for bytes:\n\t\tif (typeof serialized !== 'string' || !serialized.startsWith('{')) {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.fromBytes(\n\t\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t\t);\n\t\t} else {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.restore(JSON.parse(serialized));\n\t\t}\n\n\t\treturn tx;\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#blockData.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#blockData.sender) {\n\t\t\tthis.#blockData.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: TransactionExpiration) {\n\t\tthis.#blockData.expiration = expiration;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#blockData.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#blockData.gasConfig.budget = String(budget);\n\t}\n\tsetGasOwner(owner: string) {\n\t\tthis.#blockData.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: SuiObjectRef[]) {\n\t\tthis.#blockData.gasConfig.payment = payments.map((payment) => mask(payment, SuiObjectRef));\n\t}\n\n\t#blockData: TransactionBlockDataBuilder;\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tget blockData() {\n\t\treturn this.#blockData.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transaction blocks via postMessage\n\tget pure(): ReturnType<typeof createPure> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure((value, type) => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#input('pure', {\n\t\t\t\t\t\tPure: Array.from(value.toBytes()),\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#input(\n\t\t\t\t\t'pure',\n\t\t\t\t\tvalue instanceof Uint8Array\n\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t: type\n\t\t\t\t\t\t? Inputs.Pure(value, type)\n\t\t\t\t\t\t: value,\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor(transaction?: TransactionBlock) {\n\t\tthis.#blockData = new TransactionBlockDataBuilder(\n\t\t\ttransaction ? transaction.blockData : undefined,\n\t\t);\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas(): TransactionObjectArgument {\n\t\treturn { kind: 'GasCoin' };\n\t}\n\n\t/**\n\t * Dynamically create a new input, which is separate from the `input`. This is important\n\t * for generated clients to be able to define unique inputs that are non-overlapping with the\n\t * defined inputs.\n\t *\n\t * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this\n\t * is the format required for custom serialization.\n\t *\n\t */\n\t#input<T extends 'object' | 'pure'>(type: T, value?: unknown) {\n\t\tconst index = this.#blockData.inputs.length;\n\t\tconst input = create(\n\t\t\t{\n\t\t\t\tkind: 'Input',\n\t\t\t\t// bigints can't be serialized to JSON, so just string-convert them here:\n\t\t\t\tvalue: typeof value === 'bigint' ? String(value) : value,\n\t\t\t\tindex,\n\t\t\t\ttype,\n\t\t\t},\n\t\t\tTransactionBlockInput,\n\t\t);\n\t\tthis.#blockData.inputs.push(input);\n\t\treturn input as Extract<typeof input, { type: T }>;\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject(value: TransactionObjectInput) {\n\t\tif (typeof value === 'object' && 'kind' in value) {\n\t\t\treturn value;\n\t\t}\n\n\t\tconst id = getIdFromCallArg(value);\n\t\t// deduplicate\n\t\tconst inserted = this.#blockData.inputs.find(\n\t\t\t(i) => i.type === 'object' && id === getIdFromCallArg(i.value),\n\t\t) as Extract<TransactionArgument, { type?: 'object' }> | undefined;\n\t\treturn (\n\t\t\tinserted ??\n\t\t\tthis.#input('object', typeof value === 'string' ? normalizeSuiAddress(value) : value)\n\t\t);\n\t}\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t/** Add a transaction to the transaction block. */\n\tadd(transaction: TransactionType) {\n\t\tconst index = this.#blockData.transactions.push(transaction);\n\t\treturn createTransactionResult(index - 1);\n\t}\n\n\t#normalizeTransactionArgument(\n\t\targ: TransactionArgument | SerializedBcs<any>,\n\t): TransactionArgument {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn arg as TransactionArgument;\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins(\n\t\tcoin: TransactionObjectArgument | string,\n\t\tamounts: (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.SplitCoins(\n\t\t\t\ttypeof coin === 'string' ? this.object(coin) : coin,\n\t\t\t\tamounts.map((amount) =>\n\t\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.MergeCoins(\n\t\t\t\ttypeof destination === 'string' ? this.object(destination) : destination,\n\t\t\t\tsources.map((src) => (typeof src === 'string' ? this.object(src) : src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tTransactions.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackageId: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackageId,\n\t\t\t\tticket: typeof ticket === 'string' ? this.object(ticket) : ticket,\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\ttypeArguments,\n\t\ttarget,\n\t}: {\n\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\ttypeArguments?: string[];\n\t\ttarget: `${string}::${string}::${string}`;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.MoveCall({\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t\ttypeArguments,\n\t\t\t\ttarget,\n\t\t\t}),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.TransferObjects(\n\t\t\t\tobjects.map((obj) => (typeof obj === 'string' ? this.object(obj) : obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\tobjects,\n\t}: {\n\t\tobjects: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\tobjects: objects.map((obj) => (typeof obj === 'string' ? this.object(obj) : obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * Serialize the transaction to a string so that it can be sent to a separate context.\n\t * This is different from `build` in that it does not serialize to BCS bytes, and instead\n\t * uses a separate format that is unique to the transaction builder. This allows\n\t * us to serialize partially-complete transactions, that can then be completed and\n\t * built in a separate context.\n\t *\n\t * For example, a dapp can construct a transaction, but not provide gas objects\n\t * or a gas budget. The transaction then can be sent to the wallet, where this\n\t * information is automatically filled in (e.g. by querying for coin objects\n\t * and performing a dry run).\n\t */\n\tserialize() {\n\t\treturn JSON.stringify(this.#blockData.snapshot());\n\t}\n\n\t#getConfig(key: keyof typeof LIMITS, { protocolConfig, limits }: BuildOptions) {\n\t\t// Use the limits definition if that exists:\n\t\tif (limits && typeof limits[key] === 'number') {\n\t\t\treturn limits[key]!;\n\t\t}\n\n\t\tif (!protocolConfig) {\n\t\t\treturn DefaultOfflineLimits[key];\n\t\t}\n\n\t\t// Fallback to protocol config:\n\t\tconst attribute = protocolConfig?.attributes[LIMITS[key]];\n\t\tif (!attribute) {\n\t\t\tthrow new Error(`Missing expected protocol config: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\tconst value =\n\t\t\t'u64' in attribute ? attribute.u64 : 'u32' in attribute ? attribute.u32 : attribute.f64;\n\n\t\tif (!value) {\n\t\t\tthrow new Error(`Unexpected protocol config value found for: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\t// NOTE: Technically this is not a safe conversion, but we know all of the values in protocol config are safe\n\t\treturn Number(value);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransactionBlock(bytes);\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildOptions = {}): Promise<Uint8Array> {\n\t\tawait this.#prepare(options);\n\t\treturn this.#blockData.build({\n\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: SuiClient;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.#prepare(options);\n\t\treturn this.#blockData.getDigest();\n\t}\n\n\t#validate(options: BuildOptions) {\n\t\tconst maxPureArgumentSize = this.#getConfig('maxPureArgumentSize', options);\n\t\t// Validate all inputs are the correct size:\n\t\tthis.#blockData.inputs.forEach((input, index) => {\n\t\t\tif (is(input.value, PureCallArg)) {\n\t\t\t\tif (input.value.Pure.length > maxPureArgumentSize) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t// The current default is just picking _all_ coins we can which may not be ideal.\n\tasync #prepareGasPayment(options: BuildOptions) {\n\t\tif (this.#blockData.gasConfig.payment) {\n\t\t\tconst maxGasObjects = this.#getConfig('maxGasObjects', options);\n\t\t\tif (this.#blockData.gasConfig.payment.length > maxGasObjects) {\n\t\t\t\tthrow new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);\n\t\t\t}\n\t\t}\n\n\t\t// Early return if the payment is already set:\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.payment) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst gasOwner = this.#blockData.gasConfig.owner ?? this.#blockData.sender;\n\n\t\tconst coins = await expectClient(options).getCoins({\n\t\t\towner: gasOwner!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = this.#blockData.inputs.find((input) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tis(input.value, BuilderCallArg) &&\n\t\t\t\t\t\t'Object' in input.value &&\n\t\t\t\t\t\t'ImmOrOwned' in input.value.Object\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.slice(0, this.#getConfig('maxGasObjects', options) - 1)\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\tthis.setGasPayment(paymentCoins);\n\t}\n\n\tasync #prepareGasPrice(options: BuildOptions) {\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.price) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setGasPrice(await expectClient(options).getReferenceGasPrice());\n\t}\n\n\tasync #prepareTransactions(options: BuildOptions) {\n\t\tconst { inputs, transactions } = this.#blockData;\n\n\t\tconst moveModulesToResolve: MoveCallTransaction[] = [];\n\n\t\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t\t// We keep the input by-reference to avoid needing to re-resolve it:\n\t\tconst objectsToResolve: {\n\t\t\tid: string;\n\t\t\tinput: TransactionBlockInput;\n\t\t\tnormalizedType?: SuiMoveNormalizedType;\n\t\t}[] = [];\n\n\t\tinputs.forEach((input) => {\n\t\t\tif (input.type === 'object' && typeof input.value === 'string') {\n\t\t\t\t// The input is a string that we need to resolve to an object reference:\n\t\t\t\tobjectsToResolve.push({ id: normalizeSuiAddress(input.value), input });\n\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\n\t\ttransactions.forEach((transaction) => {\n\t\t\t// Special case move call:\n\t\t\tif (transaction.kind === 'MoveCall') {\n\t\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t\t// - If they don't, then this is good to go.\n\t\t\t\t// - If they do, then we need to fetch the normalized move module.\n\t\t\t\tconst needsResolution = transaction.arguments.some(\n\t\t\t\t\t(arg) => arg.kind === 'Input' && !is(inputs[arg.index].value, BuilderCallArg),\n\t\t\t\t);\n\n\t\t\t\tif (needsResolution) {\n\t\t\t\t\tmoveModulesToResolve.push(transaction);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special handling for values that where previously encoded using the wellKnownEncoding pattern.\n\t\t\t// This should only happen when transaction block data was hydrated from an old version of the SDK\n\t\t\tif (transaction.kind === 'SplitCoins') {\n\t\t\t\ttransaction.amounts.forEach((amount) => {\n\t\t\t\t\tif (amount.kind === 'Input') {\n\t\t\t\t\t\tconst input = inputs[amount.index];\n\t\t\t\t\t\tif (typeof input.value !== 'object') {\n\t\t\t\t\t\t\tinput.value = Inputs.Pure(bcs.U64.serialize(input.value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (transaction.kind === 'TransferObjects') {\n\t\t\t\tif (transaction.address.kind === 'Input') {\n\t\t\t\t\tconst input = inputs[transaction.address.index];\n\t\t\t\t\tif (typeof input.value !== 'object') {\n\t\t\t\t\t\tinput.value = Inputs.Pure(bcs.Address.serialize(input.value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (moveModulesToResolve.length) {\n\t\t\tawait Promise.all(\n\t\t\t\tmoveModulesToResolve.map(async (moveCall) => {\n\t\t\t\t\tconst [packageId, moduleName, functionName] = moveCall.target.split('::');\n\n\t\t\t\t\tconst normalized = await expectClient(options).getNormalizedMoveFunction({\n\t\t\t\t\t\tpackage: normalizeSuiObjectId(packageId),\n\t\t\t\t\t\tmodule: moduleName,\n\t\t\t\t\t\tfunction: functionName,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\t\tconst hasTxContext =\n\t\t\t\t\t\tnormalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1)!);\n\n\t\t\t\t\tconst params = hasTxContext\n\t\t\t\t\t\t? normalized.parameters.slice(0, normalized.parameters.length - 1)\n\t\t\t\t\t\t: normalized.parameters;\n\n\t\t\t\t\tif (params.length !== moveCall.arguments.length) {\n\t\t\t\t\t\tthrow new Error('Incorrect number of arguments.');\n\t\t\t\t\t}\n\n\t\t\t\t\tparams.forEach((param, i) => {\n\t\t\t\t\t\tconst arg = moveCall.arguments[i];\n\t\t\t\t\t\tif (arg.kind !== 'Input') return;\n\t\t\t\t\t\tconst input = inputs[arg.index];\n\t\t\t\t\t\t// Skip if the input is already resolved\n\t\t\t\t\t\tif (is(input.value, BuilderCallArg)) return;\n\n\t\t\t\t\t\tconst inputValue = input.value;\n\n\t\t\t\t\t\tconst serType = getPureSerializationType(param, inputValue);\n\n\t\t\t\t\t\tif (serType) {\n\t\t\t\t\t\t\tinput.value = Inputs.Pure(inputValue, serType);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst structVal = extractStructTag(param);\n\t\t\t\t\t\tif (structVal != null || (typeof param === 'object' && 'TypeParameter' in param)) {\n\t\t\t\t\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobjectsToResolve.push({\n\t\t\t\t\t\t\t\tid: inputValue,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tnormalizedType: param,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(\n\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tif (objectsToResolve.length) {\n\t\t\tconst dedupedIds = [...new Set(objectsToResolve.map(({ id }) => id))];\n\t\t\tconst objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);\n\t\t\tconst objects = (\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\t\t\texpectClient(options).multiGetObjects({\n\t\t\t\t\t\t\tids: chunk,\n\t\t\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t).flat();\n\n\t\t\tlet objectsById = new Map(\n\t\t\t\tdedupedIds.map((id, index) => {\n\t\t\t\t\treturn [id, objects[index]];\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tconst invalidObjects = Array.from(objectsById)\n\t\t\t\t.filter(([_, obj]) => obj.error)\n\t\t\t\t.map(([id, _]) => id);\n\t\t\tif (invalidObjects.length) {\n\t\t\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t\t\t}\n\n\t\t\tobjectsToResolve.forEach(({ id, input, normalizedType }) => {\n\t\t\t\tconst object = objectsById.get(id)!;\n\t\t\t\tconst owner = object.data?.owner;\n\t\t\t\tconst initialSharedVersion =\n\t\t\t\t\towner && typeof owner === 'object' && 'Shared' in owner\n\t\t\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t\t\t: undefined;\n\n\t\t\t\tif (initialSharedVersion) {\n\t\t\t\t\t// There could be multiple transactions that reference the same shared object.\n\t\t\t\t\t// If one of them is a mutable reference or taken by value, then we should mark the input\n\t\t\t\t\t// as mutable.\n\t\t\t\t\tconst isByValue =\n\t\t\t\t\t\tnormalizedType != null &&\n\t\t\t\t\t\textractMutableReference(normalizedType) == null &&\n\t\t\t\t\t\textractReference(normalizedType) == null;\n\t\t\t\t\tconst mutable =\n\t\t\t\t\t\tisMutableSharedObjectInput(input.value) ||\n\t\t\t\t\t\tisByValue ||\n\t\t\t\t\t\t(normalizedType != null && extractMutableReference(normalizedType) != null);\n\n\t\t\t\t\tinput.value = Inputs.SharedObjectRef({\n\t\t\t\t\t\tobjectId: id,\n\t\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\t\tmutable,\n\t\t\t\t\t});\n\t\t\t\t} else if (normalizedType && isReceivingType(normalizedType)) {\n\t\t\t\t\tinput.value = Inputs.ReceivingRef(getObjectReference(object)!);\n\t\t\t\t} else {\n\t\t\t\t\tinput.value = Inputs.ObjectRef(getObjectReference(object as SuiObjectResponse)!);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Prepare the transaction by valdiating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepare(options: BuildOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#blockData.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!options.protocolConfig && !options.limits && options.client) {\n\t\t\toptions.protocolConfig = await options.client.getProtocolConfig();\n\t\t}\n\n\t\tawait Promise.all([this.#prepareGasPrice(options), this.#prepareTransactions(options)]);\n\n\t\tif (!options.onlyTransactionKind) {\n\t\t\tawait this.#prepareGasPayment(options);\n\n\t\t\tif (!this.#blockData.gasConfig.budget) {\n\t\t\t\tconst dryRunResult = await expectClient(options).dryRunTransactionBlock({\n\t\t\t\t\ttransactionBlock: this.#blockData.build({\n\t\t\t\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\t\t\t\toverrides: {\n\t\t\t\t\t\t\tgasConfig: {\n\t\t\t\t\t\t\t\tbudget: String(this.#getConfig('maxTxGas', options)),\n\t\t\t\t\t\t\t\tpayment: [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t});\n\t\t\t\tif (dryRunResult.effects.status.status !== 'success') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t\t\t\t{ cause: dryRunResult },\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);\n\n\t\t\t\tconst baseComputationCostWithOverhead =\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\t\t\t\tconst gasBudget =\n\t\t\t\t\tbaseComputationCostWithOverhead +\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\t\t\t\t// Set the budget to max(computation, computation + storage - rebate)\n\t\t\t\tthis.setGasBudget(\n\t\t\t\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Perform final validation on the transaction:\n\t\tthis.#validate(options);\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Sui Devnet */\nexport const SUI_DEVNET_CHAIN = 'sui:devnet';\n\n/** Sui Testnet */\nexport const SUI_TESTNET_CHAIN = 'sui:testnet';\n\n/** Sui Localnet */\nexport const SUI_LOCALNET_CHAIN = 'sui:localnet';\n\n/** Sui Mainnet */\nexport const SUI_MAINNET_CHAIN = 'sui:mainnet';\n\nexport const SUI_CHAINS = [\n\tSUI_DEVNET_CHAIN,\n\tSUI_TESTNET_CHAIN,\n\tSUI_LOCALNET_CHAIN,\n\tSUI_MAINNET_CHAIN,\n] as const;\n\nexport type SuiChain =\n\t| typeof SUI_DEVNET_CHAIN\n\t| typeof SUI_TESTNET_CHAIN\n\t| typeof SUI_LOCALNET_CHAIN\n\t| typeof SUI_MAINNET_CHAIN;\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ReadonlyWalletAccount_address, _ReadonlyWalletAccount_publicKey, _ReadonlyWalletAccount_chains, _ReadonlyWalletAccount_features, _ReadonlyWalletAccount_label, _ReadonlyWalletAccount_icon;\n/**\n * Base implementation of a {@link \"@wallet-standard/base\".WalletAccount} to be used or extended by a\n * {@link \"@wallet-standard/base\".Wallet}.\n *\n * `WalletAccount` properties must be read-only. This class enforces this by making all properties\n * [truly private](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields) and\n * read-only, using getters for access, returning copies instead of references, and calling\n * [Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)\n * on the instance.\n *\n * @group Account\n */\nexport class ReadonlyWalletAccount {\n    /**\n     * Create and freeze a read-only account.\n     *\n     * @param account Account to copy properties from.\n     */\n    constructor(account) {\n        _ReadonlyWalletAccount_address.set(this, void 0);\n        _ReadonlyWalletAccount_publicKey.set(this, void 0);\n        _ReadonlyWalletAccount_chains.set(this, void 0);\n        _ReadonlyWalletAccount_features.set(this, void 0);\n        _ReadonlyWalletAccount_label.set(this, void 0);\n        _ReadonlyWalletAccount_icon.set(this, void 0);\n        if (new.target === ReadonlyWalletAccount) {\n            Object.freeze(this);\n        }\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_address, account.address, \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_publicKey, account.publicKey.slice(), \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_chains, account.chains.slice(), \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_features, account.features.slice(), \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_label, account.label, \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_icon, account.icon, \"f\");\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.address | WalletAccount::address} */\n    get address() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_address, \"f\");\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.publicKey | WalletAccount::publicKey} */\n    get publicKey() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_publicKey, \"f\").slice();\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.chains | WalletAccount::chains} */\n    get chains() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_chains, \"f\").slice();\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.features | WalletAccount::features} */\n    get features() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_features, \"f\").slice();\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.label | WalletAccount::label} */\n    get label() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_label, \"f\");\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.icon | WalletAccount::icon} */\n    get icon() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_icon, \"f\");\n    }\n}\n_ReadonlyWalletAccount_address = new WeakMap(), _ReadonlyWalletAccount_publicKey = new WeakMap(), _ReadonlyWalletAccount_chains = new WeakMap(), _ReadonlyWalletAccount_features = new WeakMap(), _ReadonlyWalletAccount_label = new WeakMap(), _ReadonlyWalletAccount_icon = new WeakMap();\n/**\n * Efficiently compare {@link Indexed} arrays (e.g. `Array` and `Uint8Array`).\n *\n * @param a An array.\n * @param b Another array.\n *\n * @return `true` if the arrays have the same length and elements, `false` otherwise.\n *\n * @group Util\n */\nexport function arraysEqual(a, b) {\n    if (a === b)\n        return true;\n    const length = a.length;\n    if (length !== b.length)\n        return false;\n    for (let i = 0; i < length; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n}\n/**\n * Efficiently compare byte arrays, using {@link arraysEqual}.\n *\n * @param a A byte array.\n * @param b Another byte array.\n *\n * @return `true` if the byte arrays have the same length and bytes, `false` otherwise.\n *\n * @group Util\n */\nexport function bytesEqual(a, b) {\n    return arraysEqual(a, b);\n}\n/**\n * Efficiently concatenate byte arrays without modifying them.\n *\n * @param first  A byte array.\n * @param others Additional byte arrays.\n *\n * @return New byte array containing the concatenation of all the byte arrays.\n *\n * @group Util\n */\nexport function concatBytes(first, ...others) {\n    const length = others.reduce((length, bytes) => length + bytes.length, first.length);\n    const bytes = new Uint8Array(length);\n    bytes.set(first, 0);\n    for (const other of others) {\n        bytes.set(other, bytes.length);\n    }\n    return bytes;\n}\n/**\n * Create a new object with a subset of fields from a source object.\n *\n * @param source Object to pick fields from.\n * @param keys   Names of fields to pick.\n *\n * @return New object with only the picked fields.\n *\n * @group Util\n */\nexport function pick(source, ...keys) {\n    const picked = {};\n    for (const key of keys) {\n        picked[key] = source[key];\n    }\n    return picked;\n}\n/**\n * Call a callback function, catch an error if it throws, and log the error without rethrowing.\n *\n * @param callback Function to call.\n *\n * @group Util\n */\nexport function guard(callback) {\n    try {\n        callback();\n    }\n    catch (error) {\n        console.error(error);\n    }\n}\n//# sourceMappingURL=util.js.map","import { createErrorClass } from './createErrorClass';\nexport var EmptyError = createErrorClass(function (_super) { return function EmptyErrorImpl() {\n    _super(this);\n    this.name = 'EmptyError';\n    this.message = 'no elements in sequence';\n}; });\n//# sourceMappingURL=EmptyError.js.map","import { Observable } from '../Observable';\nexport var EMPTY = new Observable(function (subscriber) { return subscriber.complete(); });\nexport function empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });\n}\n//# sourceMappingURL=empty.js.map","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isErrorPayload, type Payload } from '_payloads';\nimport { lastValueFrom, map, take, type Observable } from 'rxjs';\n\nexport function mapToPromise<T extends Payload | void, R>(\n\tstream: Observable<T>,\n\tproject: (value: T) => R,\n) {\n\treturn lastValueFrom(\n\t\tstream.pipe(\n\t\t\ttake<T>(1),\n\t\t\tmap<T, R>((response) => {\n\t\t\t\tif (response && isErrorPayload(response)) {\n\t\t\t\t\t// TODO: throw proper error\n\t\t\t\t\tthrow new Error(response.message);\n\t\t\t\t}\n\t\t\t\treturn project(response);\n\t\t\t}),\n\t\t),\n\t);\n}\n","import { EmptyError } from './util/EmptyError';\nexport function lastValueFrom(source, config) {\n    var hasConfig = typeof config === 'object';\n    return new Promise(function (resolve, reject) {\n        var _hasValue = false;\n        var _value;\n        source.subscribe({\n            next: function (value) {\n                _value = value;\n                _hasValue = true;\n            },\n            error: reject,\n            complete: function () {\n                if (_hasValue) {\n                    resolve(_value);\n                }\n                else if (hasConfig) {\n                    resolve(config.defaultValue);\n                }\n                else {\n                    reject(new EmptyError());\n                }\n            },\n        });\n    });\n}\n//# sourceMappingURL=lastValueFrom.js.map","import { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function take(count) {\n    return count <= 0\n        ?\n            function () { return EMPTY; }\n        : operate(function (source, subscriber) {\n            var seen = 0;\n            source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n                if (++seen <= count) {\n                    subscriber.next(value);\n                    if (count <= seen) {\n                        subscriber.complete();\n                    }\n                }\n            }));\n        });\n}\n//# sourceMappingURL=take.js.map","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Payload } from './Payload';\n\nexport interface ErrorPayload {\n\terror: true;\n\tcode: number;\n\tmessage: string;\n}\n\nexport function isErrorPayload(payload: Payload): payload is ErrorPayload {\n\treturn 'error' in payload && payload.error === true;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { createMessage } from '_messages';\nimport { WindowMessageStream } from '_messaging/WindowMessageStream';\nimport type { BasePayload, Payload } from '_payloads';\nimport type { GetAccount } from '_payloads/account/GetAccount';\nimport type { GetAccountResponse } from '_payloads/account/GetAccountResponse';\nimport type { SetNetworkPayload } from '_payloads/network';\nimport {\n\tALL_PERMISSION_TYPES,\n\ttype AcquirePermissionsRequest,\n\ttype AcquirePermissionsResponse,\n\ttype HasPermissionsRequest,\n\ttype HasPermissionsResponse,\n} from '_payloads/permissions';\nimport type {\n\tExecuteTransactionRequest,\n\tExecuteTransactionResponse,\n\tSignTransactionRequest,\n\tSignTransactionResponse,\n} from '_payloads/transactions';\nimport { API_ENV } from '_src/shared/api-env';\nimport type { NetworkEnvType } from '_src/shared/api-env';\nimport {\n\tisQredoConnectPayload,\n\ttype QredoConnectPayload,\n} from '_src/shared/messaging/messages/payloads/QredoConnect';\nimport { type SignMessageRequest } from '_src/shared/messaging/messages/payloads/transactions/SignMessage';\nimport { isWalletStatusChangePayload } from '_src/shared/messaging/messages/payloads/wallet-status-change';\nimport { isTransactionBlock } from '@mysten/sui.js/transactions';\nimport { fromB64, toB64 } from '@mysten/sui.js/utils';\nimport {\n\tReadonlyWalletAccount,\n\tSUI_CHAINS,\n\tSUI_DEVNET_CHAIN,\n\tSUI_LOCALNET_CHAIN,\n\tSUI_MAINNET_CHAIN,\n\tSUI_TESTNET_CHAIN,\n\ttype StandardConnectFeature,\n\ttype StandardConnectMethod,\n\ttype StandardEventsFeature,\n\ttype StandardEventsListeners,\n\ttype StandardEventsOnMethod,\n\ttype SuiFeatures,\n\ttype SuiSignAndExecuteTransactionBlockMethod,\n\ttype SuiSignMessageMethod,\n\ttype SuiSignPersonalMessageMethod,\n\ttype SuiSignTransactionBlockMethod,\n\ttype Wallet,\n} from '@mysten/wallet-standard';\nimport mitt, { type Emitter } from 'mitt';\nimport { filter, map, type Observable } from 'rxjs';\n\nimport { mapToPromise } from './utils';\n\ntype WalletEventsMap = {\n\t[E in keyof StandardEventsListeners]: Parameters<StandardEventsListeners[E]>[0];\n};\n\n// NOTE: Because this runs in a content script, we can't fetch the manifest.\nconst name = process.env.APP_NAME || 'Sui Wallet';\n\nexport type QredoConnectInput = {\n\tservice: string;\n\tapiUrl: string;\n\ttoken: string;\n} & (\n\t| {\n\t\t\t/** @deprecated renamed to workspace, please use that */\n\t\t\torganization: string;\n\t  }\n\t| {\n\t\t\tworkspace: string;\n\t  }\n);\n\ntype QredoConnectFeature = {\n\t'qredo:connect': {\n\t\tversion: '0.0.1';\n\t\tqredoConnect: (input: QredoConnectInput) => Promise<void>;\n\t};\n};\ntype ChainType = Wallet['chains'][number];\nconst API_ENV_TO_CHAIN: Record<Exclude<API_ENV, API_ENV.customRPC>, ChainType> = {\n\t[API_ENV.local]: SUI_LOCALNET_CHAIN,\n\t[API_ENV.devNet]: SUI_DEVNET_CHAIN,\n\t[API_ENV.testNet]: SUI_TESTNET_CHAIN,\n\t[API_ENV.mainnet]: SUI_MAINNET_CHAIN,\n};\n\nexport class SuiWallet implements Wallet {\n\treadonly #events: Emitter<WalletEventsMap>;\n\treadonly #version = '1.0.0' as const;\n\treadonly #name = name;\n\t#accounts: ReadonlyWalletAccount[];\n\t#messagesStream: WindowMessageStream;\n\t#activeChain: ChainType | null = null;\n\n\tget version() {\n\t\treturn this.#version;\n\t}\n\n\tget name() {\n\t\treturn this.#name;\n\t}\n\n\tget icon() {\n\t\treturn 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzIiIGhlaWdodD0iNzIiIHZpZXdCb3g9IjAgMCA3MiA3MiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjcyIiBoZWlnaHQ9IjcyIiByeD0iMTYiIGZpbGw9IiM2RkJDRjAiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0yMC40MjEzIDUyLjc4MzhDMjMuNjQ5NiA1OC4zNzYgMjkuNDMyMSA2MS43MTQyIDM1Ljg4ODggNjEuNzE0MkM0Mi4zNDU1IDYxLjcxNDIgNDguMTI3IDU4LjM3NiA1MS4zNTY0IDUyLjc4MzhDNTQuNTg0OCA0Ny4xOTI2IDU0LjU4NDggNDAuNTE2MyA1MS4zNTY0IDM0LjkyNEwzNy43NTI0IDExLjM2MTVDMzYuOTI0MSA5LjkyNzAxIDM0Ljg1MzUgOS45MjcwMSAzNC4wMjUzIDExLjM2MTVMMjAuNDIxMyAzNC45MjRDMTcuMTkyOSA0MC41MTUyIDE3LjE5MjkgNDcuMTkxNSAyMC40MjEzIDUyLjc4MzhaTTMyLjA1NjYgMjIuNTcxM0wzNC45NTcxIDE3LjU0NzRDMzUuMzcxMiAxNi44MzAxIDM2LjQwNjUgMTYuODMwMSAzNi44MjA2IDE3LjU0NzRMNDcuOTc5MSAzNi44NzQ4QzUwLjAyOTEgNDAuNDI1NCA1MC40MTM5IDQ0LjUzNSA0OS4xMzM1IDQ4LjI5NTRDNDkuMDAwMiA0Ny42ODE5IDQ4LjgxMzggNDcuMDU0MiA0OC41NjI2IDQ2LjQyMDFDNDcuMDIxMyA0Mi41MzA0IDQzLjUzNjMgMzkuNTI4OSAzOC4yMDIzIDM3LjQ5ODJDMzQuNTM1MSAzNi4xMDcxIDMyLjE5NDMgMzQuMDYxMyAzMS4yNDMxIDMxLjQxNzFDMzAuMDE4IDI4LjAwODkgMzEuMjk3NiAyNC4yOTI0IDMyLjA1NjYgMjIuNTcxM1pNMjcuMTEwNyAzMS4xMzc5TDIzLjc5ODYgMzYuODc0OEMyMS4yNzQ4IDQxLjI0NTkgMjEuMjc0OCA0Ni40NjQxIDIzLjc5ODYgNTAuODM1M0MyNi4zMjIzIDU1LjIwNjQgMzAuODQxMyA1Ny44MTUgMzUuODg4OCA1Ny44MTVDMzkuMjQxMyA1Ny44MTUgNDIuMzYxNSA1Ni42NjMzIDQ0LjgxODQgNTQuNjA4OEM0NS4xMzg4IDUzLjgwMjEgNDYuMTMxIDUwLjg0OTIgNDQuOTA1MiA0Ny44MDU4QzQzLjc3MyA0NC45OTU0IDQxLjA0ODIgNDIuNzUxOSAzNi44MDYxIDQxLjEzNkMzMi4wMTEgMzkuMzE3MSAyOC44OTU4IDM2LjQ3NzQgMjcuNTQ4NiAzMi42OTg0QzI3LjM2MzEgMzIuMTc4MSAyNy4yMTg5IDMxLjY1NjggMjcuMTEwNyAzMS4xMzc5WiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+' as const;\n\t}\n\n\tget chains() {\n\t\t// TODO: Extract chain from wallet:\n\t\treturn SUI_CHAINS;\n\t}\n\n\tget features(): StandardConnectFeature &\n\t\tStandardEventsFeature &\n\t\tSuiFeatures &\n\t\tQredoConnectFeature {\n\t\treturn {\n\t\t\t'standard:connect': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tconnect: this.#connect,\n\t\t\t},\n\t\t\t'standard:events': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\ton: this.#on,\n\t\t\t},\n\t\t\t'sui:signTransactionBlock': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tsignTransactionBlock: this.#signTransactionBlock,\n\t\t\t},\n\t\t\t'sui:signAndExecuteTransactionBlock': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tsignAndExecuteTransactionBlock: this.#signAndExecuteTransactionBlock,\n\t\t\t},\n\t\t\t'sui:signMessage': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tsignMessage: this.#signMessage,\n\t\t\t},\n\t\t\t'sui:signPersonalMessage': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tsignPersonalMessage: this.#signPersonalMessage,\n\t\t\t},\n\t\t\t'qredo:connect': {\n\t\t\t\tversion: '0.0.1',\n\t\t\t\tqredoConnect: this.#qredoConnect,\n\t\t\t},\n\t\t};\n\t}\n\n\tget accounts() {\n\t\treturn this.#accounts;\n\t}\n\n\t#setAccounts(accounts: GetAccountResponse['accounts']) {\n\t\tthis.#accounts = accounts.map(\n\t\t\t({ address, publicKey, nickname }) =>\n\t\t\t\tnew ReadonlyWalletAccount({\n\t\t\t\t\taddress,\n\t\t\t\t\tlabel: nickname || undefined,\n\t\t\t\t\tpublicKey: publicKey ? fromB64(publicKey) : new Uint8Array(),\n\t\t\t\t\tchains: this.#activeChain ? [this.#activeChain] : [],\n\t\t\t\t\tfeatures: ['sui:signAndExecuteTransaction'],\n\t\t\t\t}),\n\t\t);\n\t}\n\n\tconstructor() {\n\t\tthis.#events = mitt();\n\t\tthis.#accounts = [];\n\t\tthis.#messagesStream = new WindowMessageStream('sui_in-page', 'sui_content-script');\n\t\tthis.#messagesStream.messages.subscribe(({ payload }) => {\n\t\t\tif (isWalletStatusChangePayload(payload)) {\n\t\t\t\tconst { network, accounts } = payload;\n\t\t\t\tif (network) {\n\t\t\t\t\tthis.#setActiveChain(network);\n\t\t\t\t\tif (!accounts) {\n\t\t\t\t\t\t// in case an accounts change exists skip updating chains of current accounts\n\t\t\t\t\t\t// accounts will be updated in the if block below\n\t\t\t\t\t\tthis.#accounts = this.#accounts.map(\n\t\t\t\t\t\t\t({ address, features, icon, label, publicKey }) =>\n\t\t\t\t\t\t\t\tnew ReadonlyWalletAccount({\n\t\t\t\t\t\t\t\t\taddress,\n\t\t\t\t\t\t\t\t\tpublicKey,\n\t\t\t\t\t\t\t\t\tchains: this.#activeChain ? [this.#activeChain] : [],\n\t\t\t\t\t\t\t\t\tfeatures,\n\t\t\t\t\t\t\t\t\tlabel,\n\t\t\t\t\t\t\t\t\ticon,\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (accounts) {\n\t\t\t\t\tthis.#setAccounts(accounts);\n\t\t\t\t}\n\t\t\t\tthis.#events.emit('change', { accounts: this.accounts });\n\t\t\t}\n\t\t});\n\t}\n\n\t#on: StandardEventsOnMethod = (event, listener) => {\n\t\tthis.#events.on(event, listener);\n\t\treturn () => this.#events.off(event, listener);\n\t};\n\n\t#connected = async () => {\n\t\tthis.#setActiveChain(await this.#getActiveNetwork());\n\t\tif (!(await this.#hasPermissions(['viewAccount']))) {\n\t\t\treturn;\n\t\t}\n\t\tconst accounts = await this.#getAccounts();\n\t\tthis.#setAccounts(accounts);\n\t\tif (this.#accounts.length) {\n\t\t\tthis.#events.emit('change', { accounts: this.accounts });\n\t\t}\n\t};\n\n\t#connect: StandardConnectMethod = async (input) => {\n\t\tif (!input?.silent) {\n\t\t\tawait mapToPromise(\n\t\t\t\tthis.#send<AcquirePermissionsRequest, AcquirePermissionsResponse>({\n\t\t\t\t\ttype: 'acquire-permissions-request',\n\t\t\t\t\tpermissions: ALL_PERMISSION_TYPES,\n\t\t\t\t}),\n\t\t\t\t(response) => response.result,\n\t\t\t);\n\t\t}\n\n\t\tawait this.#connected();\n\n\t\treturn { accounts: this.accounts };\n\t};\n\n\t#signTransactionBlock: SuiSignTransactionBlockMethod = async ({\n\t\ttransactionBlock,\n\t\taccount,\n\t\t...input\n\t}) => {\n\t\tif (!isTransactionBlock(transactionBlock)) {\n\t\t\tthrow new Error(\n\t\t\t\t'Unexpect transaction format found. Ensure that you are using the `Transaction` class.',\n\t\t\t);\n\t\t}\n\n\t\treturn mapToPromise(\n\t\t\tthis.#send<SignTransactionRequest, SignTransactionResponse>({\n\t\t\t\ttype: 'sign-transaction-request',\n\t\t\t\ttransaction: {\n\t\t\t\t\t...input,\n\t\t\t\t\t// account might be undefined if previous version of adapters is used\n\t\t\t\t\t// in that case use the first account address\n\t\t\t\t\taccount: account?.address || this.#accounts[0]?.address || '',\n\t\t\t\t\ttransaction: transactionBlock.serialize(),\n\t\t\t\t},\n\t\t\t}),\n\t\t\t(response) => response.result,\n\t\t);\n\t};\n\n\t#signAndExecuteTransactionBlock: SuiSignAndExecuteTransactionBlockMethod = async (input) => {\n\t\tif (!isTransactionBlock(input.transactionBlock)) {\n\t\t\tthrow new Error(\n\t\t\t\t'Unexpect transaction format found. Ensure that you are using the `Transaction` class.',\n\t\t\t);\n\t\t}\n\n\t\treturn mapToPromise(\n\t\t\tthis.#send<ExecuteTransactionRequest, ExecuteTransactionResponse>({\n\t\t\t\ttype: 'execute-transaction-request',\n\t\t\t\ttransaction: {\n\t\t\t\t\ttype: 'transaction',\n\t\t\t\t\tdata: input.transactionBlock.serialize(),\n\t\t\t\t\toptions: input.options,\n\t\t\t\t\t// account might be undefined if previous version of adapters is used\n\t\t\t\t\t// in that case use the first account address\n\t\t\t\t\taccount: input.account?.address || this.#accounts[0]?.address || '',\n\t\t\t\t},\n\t\t\t}),\n\t\t\t(response) => response.result,\n\t\t);\n\t};\n\n\t#signMessage: SuiSignMessageMethod = async ({ message, account }) => {\n\t\treturn mapToPromise(\n\t\t\tthis.#send<SignMessageRequest, SignMessageRequest>({\n\t\t\t\ttype: 'sign-message-request',\n\t\t\t\targs: {\n\t\t\t\t\tmessage: toB64(message),\n\t\t\t\t\taccountAddress: account.address,\n\t\t\t\t},\n\t\t\t}),\n\t\t\t(response) => {\n\t\t\t\tif (!response.return) {\n\t\t\t\t\tthrow new Error('Invalid sign message response');\n\t\t\t\t}\n\t\t\t\treturn response.return;\n\t\t\t},\n\t\t);\n\t};\n\n\t#signPersonalMessage: SuiSignPersonalMessageMethod = async ({ message, account }) => {\n\t\treturn mapToPromise(\n\t\t\tthis.#send<SignMessageRequest, SignMessageRequest>({\n\t\t\t\ttype: 'sign-message-request',\n\t\t\t\targs: {\n\t\t\t\t\tmessage: toB64(message),\n\t\t\t\t\taccountAddress: account.address,\n\t\t\t\t},\n\t\t\t}),\n\t\t\t(response) => {\n\t\t\t\tif (!response.return) {\n\t\t\t\t\tthrow new Error('Invalid sign message response');\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tbytes: response.return.messageBytes,\n\t\t\t\t\tsignature: response.return.signature,\n\t\t\t\t};\n\t\t\t},\n\t\t);\n\t};\n\n\t#hasPermissions(permissions: HasPermissionsRequest['permissions']) {\n\t\treturn mapToPromise(\n\t\t\tthis.#send<HasPermissionsRequest, HasPermissionsResponse>({\n\t\t\t\ttype: 'has-permissions-request',\n\t\t\t\tpermissions: permissions,\n\t\t\t}),\n\t\t\t({ result }) => result,\n\t\t);\n\t}\n\n\t#getAccounts() {\n\t\treturn mapToPromise(\n\t\t\tthis.#send<GetAccount, GetAccountResponse>({\n\t\t\t\ttype: 'get-account',\n\t\t\t}),\n\t\t\t(response) => response.accounts,\n\t\t);\n\t}\n\n\t#getActiveNetwork() {\n\t\treturn mapToPromise(\n\t\t\tthis.#send<BasePayload, SetNetworkPayload>({\n\t\t\t\ttype: 'get-network',\n\t\t\t}),\n\t\t\t({ network }) => network,\n\t\t);\n\t}\n\n\t#setActiveChain({ env }: NetworkEnvType) {\n\t\tthis.#activeChain = env === API_ENV.customRPC ? 'sui:unknown' : API_ENV_TO_CHAIN[env];\n\t}\n\n\t#qredoConnect = async (input: QredoConnectInput): Promise<void> => {\n\t\tconst allowed = await mapToPromise(\n\t\t\tthis.#send<QredoConnectPayload<'connect'>, QredoConnectPayload<'connectResponse'>>({\n\t\t\t\ttype: 'qredo-connect',\n\t\t\t\tmethod: 'connect',\n\t\t\t\targs: { ...input },\n\t\t\t}),\n\t\t\t(response) => {\n\t\t\t\tif (!isQredoConnectPayload(response, 'connectResponse')) {\n\t\t\t\t\tthrow new Error('Invalid qredo connect response');\n\t\t\t\t}\n\t\t\t\treturn response.args.allowed;\n\t\t\t},\n\t\t);\n\t\tif (!allowed) {\n\t\t\tthrow new Error('Rejected by user');\n\t\t}\n\t};\n\n\t#send<RequestPayload extends Payload, ResponsePayload extends Payload | void = void>(\n\t\tpayload: RequestPayload,\n\t\tresponseForID?: string,\n\t): Observable<ResponsePayload> {\n\t\tconst msg = createMessage(payload, responseForID);\n\t\tthis.#messagesStream.send(msg);\n\t\treturn this.#messagesStream.messages.pipe(\n\t\t\tfilter(({ id }) => id === msg.id),\n\t\t\tmap((msg) => msg.payload as ResponsePayload),\n\t\t);\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { v4 as uuidV4 } from 'uuid';\n\nimport type { Payload } from './payloads/Payload';\n\nexport type Message = {\n\tid: string;\n\tpayload: Payload;\n};\n\nexport function createMessage<MsgPayload extends Payload>(\n\tpayload: MsgPayload,\n\tid?: string,\n): Message {\n\treturn {\n\t\tid: id || uuidV4(),\n\t\tpayload,\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { registerWallet } from '@mysten/wallet-standard';\n\nimport { SuiWallet } from './WalletStandardInterface';\n\nregisterWallet(new SuiWallet());\n","export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.mjs.map\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { type QredoSerializedUiAccount } from '_src/background/accounts/QredoAccount';\nimport { type UIQredoInfo, type UIQredoPendingRequest } from '_src/background/qredo/types';\nimport { type QredoConnectInput } from '_src/dapp-interface/WalletStandardInterface';\nimport { type Wallet } from '_src/shared/qredo-api';\n\nimport { isBasePayload, type BasePayload } from './BasePayload';\nimport { type Payload } from './Payload';\n\ntype Methods = {\n\tconnect: QredoConnectInput;\n\tconnectResponse: { allowed: boolean };\n\tgetPendingRequest: { requestID: string };\n\tgetPendingRequestResponse: { request: UIQredoPendingRequest | null };\n\tgetQredoInfo: {\n\t\tqredoID: string;\n\t\trefreshAccessToken: boolean;\n\t};\n\tgetQredoInfoResponse: { qredoInfo: UIQredoInfo | null };\n\tacceptQredoConnection: {\n\t\tqredoID: string;\n\t\taccounts: Wallet[];\n\t\tpassword: string;\n\t};\n\tacceptQredoConnectionResponse: { accounts: QredoSerializedUiAccount[] };\n\trejectQredoConnection: {\n\t\tqredoID: string;\n\t};\n};\n\nexport interface QredoConnectPayload<M extends keyof Methods> extends BasePayload {\n\ttype: 'qredo-connect';\n\tmethod: M;\n\targs: Methods[M];\n}\n\nexport function isQredoConnectPayload<M extends keyof Methods>(\n\tpayload: Payload,\n\tmethod: M,\n): payload is QredoConnectPayload<M> {\n\treturn (\n\t\tisBasePayload(payload) &&\n\t\tpayload.type === 'qredo-connect' &&\n\t\t'method' in payload &&\n\t\tpayload.method === method &&\n\t\t'args' in payload &&\n\t\t!!payload.args\n\t);\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isBasePayload } from '_payloads';\nimport type { BasePayload, Payload } from '_payloads';\nimport type { NetworkEnvType } from '_src/shared/api-env';\n\nexport type WalletStatusChange = {\n\tnetwork?: NetworkEnvType;\n\taccounts?: { address: string; publicKey: string | null; nickname: string | null }[];\n};\n\nexport interface WalletStatusChangePayload extends BasePayload, WalletStatusChange {\n\ttype: 'wallet-status-changed';\n}\n\nexport function isWalletStatusChangePayload(\n\tpayload: Payload,\n): payload is WalletStatusChangePayload {\n\treturn isBasePayload(payload) && payload.type === 'wallet-status-changed';\n}\n"],"names":["_global","module","exports","ALPHABET","length","TypeError","BASE_MAP","Uint8Array","j","i","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","psz","zeroes","size","b256","carry","it3","Error","it4","vch","encode","ArrayBuffer","isView","buffer","byteOffset","byteLength","Array","isArray","from","pbegin","pend","b58","it1","it2","str","repeat","decode","string","basex","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","this","Function","e","window","obj","prop","prototype","hasOwnProperty","call","self","SENTRY_RELEASE","id","SENTRY_RELEASES","_RegisterWalletEvent_detail","RegisterWalletEvent","Event","constructor","callback","super","bubbles","cancelable","composed","set","receiver","state","value","kind","f","has","__classPrivateFieldSet","detail","__classPrivateFieldGet","type","preventDefault","stopImmediatePropagation","stopPropagation","WeakMap","randomUUID","crypto","bind","getRandomValues","rnds8","rng","byteToHex","push","toString","slice","options","buf","offset","rnds","random","arr","toLowerCase","unsafeStringify","extendStatics","b","setPrototypeOf","__proto__","p","__extends","String","__","create","__generator","thisArg","body","y","t","_","label","sent","trys","ops","next","verb","Symbol","iterator","v","op","done","pop","step","__values","s","m","__read","r","ar","error","__spreadArray","to","pack","arguments","l","concat","__await","SuppressedError","isArrayLike","isFunction","createErrorClass","createImpl","ctorFunc","instance","stack","UnsubscriptionError","_super","errors","message","map","err","join","name","arrRemove","item","index","indexOf","splice","Subscription","initialTeardown","closed","_parentage","_finalizers","unsubscribe","e_1","_a","e_2","_b","_parentage_1","_parentage_1_1","remove","e_1_1","return","initialFinalizer","_finalizers_1","_finalizers_1_1","finalizer","execFinalizer","e_2_1","add","teardown","_hasParent","_addParent","parent","includes","_removeParent","EMPTY","empty","EMPTY_SUBSCRIPTION","isSubscription","config","onUnhandledError","onStoppedNotification","Promise","useDeprecatedSynchronousErrorHandling","useDeprecatedNextContext","timeoutProvider","setTimeout","handler","timeout","args","_i","delegate","apply","clearTimeout","handle","reportUnhandledError","noop","COMPLETE_NOTIFICATION","createNotification","context","errorContext","cb","isRoot","errorThrown","Subscriber","destination","_this","isStopped","EMPTY_OBSERVER","complete","SafeSubscriber","handleStoppedNotification","nextNotification","_next","_error","_complete","_bind","fn","ConsumerObserver","partialObserver","handleUnhandledError","observerOrNext","context_1","notification","subscriber","observable","identity","Observable","subscribe","_subscribe","lift","operator","isObserver","_trySubscribe","sink","forEach","promiseCtor","getPromiseCtor","resolve","reject","pipe","operations","fns","input","reduce","prev","toPromise","innerFrom","isInteropObservable","obs","array","fromArrayLike","then","promise","asyncIterator","isAsyncIterable","fromAsyncIterable","isIterable","iterable","iterable_1","iterable_1_1","getReader","isReadableStreamLike","readableStream","_arguments","generator","q","resume","fulfill","settle","shift","__asyncGenerator","reader","read","releaseLock","readableStreamLikeToAsyncGenerator","createInvalidObservableTypeError","asyncIterable","asyncIterable_1","asyncIterable_1_1","P","__asyncValues","fulfilled","rejected","result","process","catch","operate","init","hasLift","liftedSource","createOperatorSubscriber","onNext","onComplete","onError","onFinalize","OperatorSubscriber","shouldUnsubscribe","closed_1","project","mergeMap","resultSelector","concurrent","Infinity","ii","onBeforeNext","expand","innerSubScheduler","additionalFinalizer","active","isComplete","checkComplete","outerNext","doInnerSub","innerComplete","innerValue","_loop_1","bufferedValue","mergeInternals","nodeEventEmitterMethods","eventTargetMethods","jqueryMethods","fromEvent","target","eventName","callOrApply","addEventListener","removeEventListener","isEventTarget","methodName","addListener","removeListener","isNodeStyleEventEmitter","toCommonHandlerRegistry","on","off","isJQueryStyleEventEmitter","subTarget","filter","predicate","ObjectUnsubscribedError","Subject","currentObservers","observers","hasError","thrownError","subject","AnonymousSubject","_throwIfClosed","_c","configurable","_checkFinalizedStatuses","_innerSubscribe","asObservable","handleReset","reset","onSubscriber","WindowMessageStream","_name","_target","messages","data","payload","connector","resetOnError","resetOnComplete","_d","resetOnRefCountZero","wrapperSource","connection","resetConnection","refCount","hasCompleted","hasErrored","cancelReset","resetAndUnsubscribe","conn","dest","share","send","msg","postMessage","ALL_PERMISSION_TYPES","API_ENV","isBasePayload","local","testNet","devNet","mainnet","customRPC","toB58","sBase64","nBlocksSize","nMod3","nMod4","nChr","sB64Enc","replace","nInLen","nOutLen","ceil","taBytes","nUint24","nOutIdx","nInIdx","uint6ToB64","nUint6","toB64","aBytes","nLen","nIdx","fromCodePoint","fromHEX","hexStr","normalized","startsWith","padded","intArr","match","byte","parseInt","toHEX","bytes","padStart","ulebEncode","num","len","BcsReader","bytePosition","dataView","DataView","read8","getUint8","read16","getUint16","read32","getUint32","read64","value1","BigInt","read128","read256","readBytes","start","readULEB","total","ulebDecode","readVec","genericSeparators","left","right","tok","word","nestedAngleBrackets","char","trim","BcsWriter","maxSize","allocateSize","ensureSizeOrGrow","requiredSize","nextSize","min","nextBuffer","write8","setUint8","Number","write16","setUint16","write32","setUint32","write64","toLittleEndian","el","write128","write256","writeULEB","writeVec","vector","toBytes","encoding","encodeStr","bigint","BcsType","serializedSize","write","serialize","writer","validate","SerializedBcs","parse","transform","output","SERIALIZED_BCS_BRAND","for","schema","toHex","toBase64","toBase58","fixedSizeBcsType","uIntBcsType","readMethod","writeMethod","maxValue","bigUIntBcsType","val","StructError","failure","failures","cached","explanation","rest","path","cause","assign","isObject","print","JSON","stringify","toFailure","struct","branch","refinement","toFailures","run","coerce","mask","ctx","coercer","status","validator","k","entries","ts","Map","Set","refiner","Struct","props","assert","is","tuples","tuple","shiftIterator","Structs","isType","schemas","keys","object","any","Element","integer","isNaN","isInteger","literal","constant","description","never","nullable","number","knowns","Never","unknowns","delete","optional","record","Key","Value","max","union","S","coerced","first","unknown","BCS","tempKey","counter","types","registerAddressType","ADDRESS","addressLength","addressEncoding","registerVectorType","vectorType","structs","registerStructType","enums","registerEnumType","aliases","registerAlias","withPrimitives","bcs","registerType","U8","u8","U16","u16","U32","u32","U64","U128","U256","BOOL","STRING","fromCharCode","_str","HEX","BASE58","BASE64","registerPrimitives","ser","params","parseTypeName","getTypeInterface","de","decodeStr","temp","hasType","forType","typeName","encodeCb","decodeCb","validateCb","generics","typeParams","typeMap","acc","_encodeRaw","_decodeRaw","registerBcsType","createType","param","typeInterface","elementType","innerName","innerParams","fields","internalName","freeze","canonicalOrder","structName","fieldType","fieldParams","paramIdx","fieldName","variants","canonicalTypeParams","orderByte","invariant","invariantType","paramIndex","typeOrParam","chain","l_bound","r_bound","reverse","VECTOR","u64","u128","u256","bool","uleb128","dynamicSizeBcsType","fromBytes","hex","stringLikeBcsType","TextEncoder","TextDecoder","fixedArray","option","enum","None","Some","values","field","optionName","optionType","hasOwn","keyType","valueType","generic","names","lazy","lazyType","getType","lazyBcsType","forceAdd0x","address","normalizeSuiObjectId","VECTOR_REGEX","STRUCT_REGEX","TypeTagSerializer","static","normalizeAddress","signer","vectorMatch","parseFromStr","structMatch","parseStructTypeArgs","tag","tagToString","bcsRegistry","unsafe_u64","enumKind","Address","ObjectDigest","objectId","version","digest","SharedObjectRef","initialSharedVersion","mutable","ObjectArg","ImmOrOwned","Shared","Receiving","CallArg","Pure","ObjVec","TypeTag","StructTag","Argument","GasCoin","Input","Result","NestedResult","resultIndex","ProgrammableMoveCall","package","function","type_arguments","pkg","fun","split","typeArguments","Transaction","MoveCall","TransferObjects","objects","SplitCoins","coin","amounts","MergeCoins","sources","Publish","modules","dependencies","MakeMoveVec","optionEnum","Upgrade","packageId","ticket","ProgrammableTransaction","inputs","transactions","TransactionKind","ChangeEpoch","Genesis","ConsensusCommitPrologue","TransactionExpiration","Epoch","GasData","payment","owner","price","budget","TransactionDataV1","sender","gasData","expiration","TransactionData","V1","SenderSignedData","txSignatures","CompressedSignature","ED25519","Secp256k1","Secp256r1","ZkLogin","PublicKey","MultiSigPkMap","pubKey","weight","MultiSigPublicKey","pk_map","threshold","MultiSig","sigs","bitmap","multisig_pk","suiBcs","ULEB128","Bool","SuiObjectRef","T","SuiMoveModuleId","SuiMoveVisibility","SuiMoveAbilitySet","abilities","SuiMoveStructTypeParameter","constraints","isPhantom","SuiMoveNormalizedTypeParameterType","TypeParameter","MoveCallMetric","isSuiMoveNormalizedType","isSuiMoveNormalizedStructType","valueProperties","Reference","SuiMoveNormalizedType","MutableReference","Vector","rank3Days","rank7Days","rank30Days","structProperties","every","SuiMoveNormalizedFunction","visibility","isEntry","typeParameters","parameters","SuiMoveNormalizedField","SuiMoveNormalizedStruct","SuiMoveNormalizedModule","fileFormatVersion","friends","exposedFunctions","extractMutableReference","normalizedType","extractReference","extractStructTag","ref","mutRef","AddressOwner","ObjectOwner","initial_shared_version","ProtocolConfigValue","f64","attributes","featureFlags","maxSupportedProtocolVersion","minSupportedProtocolVersion","protocolVersion","SuiObjectInfo","reference","sequenceNumber","previousTransaction","ObjectContentFields","MovePackageContent","SuiMoveObject","hasPublicTransfer","SuiMovePackage","disassembled","SuiParsedData","dataType","SuiRawMoveObject","bcsBytes","SuiRawMovePackage","moduleMap","SuiRawData","SuiObjectResponseError","code","object_id","parent_object_id","DisplayFieldsBackwardCompatibleResponse","SuiObjectData","content","storageRebate","display","SuiObjectResponse","showType","showContent","showBcs","showOwner","showPreviousTransaction","showStorageRebate","showDisplay","getObjectReference","resp","exists","getSuiObjectData","getObjectDeletedResponse","atCheckpoint","nextCursor","hasNextPage","details","asked_version","latest_version","MOVE_STDLIB_ADDRESS","PureCallArg","ObjectCallArg","BuilderCallArg","RESOLVED_SUI_ID","RESOLVED_ASCII_STR","RESOLVED_UTF8_STR","RESOLVED_STD_OPTION","isSameStruct","expectType","argVal","allowedTypes","getPureSerializationType","test","isHex","getHexByteLength","innerType","TransactionBlockInput","TransactionArgument","MoveCallTransaction","TransferObjectsTransaction","SplitCoinsTransaction","MergeCoinsTransaction","MakeMoveVecTransaction","some","PublishTransaction","UpgradePolicy","DefaultOfflineLimits","maxPureArgumentSize","maxTxGas","maxGasObjects","maxTxSizeBytes","expectClient","client","TRANSACTION_BRAND","LIMITS","isTransactionBlock","TransactionBlock","serialized","tx","TransactionBlockDataBuilder","fromKindBytes","fromB64","restore","setSender","setSenderIfNotSet","setExpiration","setGasPrice","gasConfig","setGasBudget","setGasOwner","setGasPayment","payments","blockData","snapshot","pure","createPure","isSerializedBcs","Inputs","transaction","gas","getIdFromCallArg","find","normalizeSuiAddress","objectRef","ObjectRef","receivingRef","ReceivingRef","sharedObjectRef","nestedResults","nestedResultFor","Proxy","property","Reflect","createTransactionResult","splitCoins","Transactions","amount","mergeCoins","src","publish","upgrade","moveCall","arg","transferObjects","makeMoveVec","async","buildOptions","build","signTransactionBlock","maxSizeBytes","onlyTransactionKind","getDigest","protocolConfig","limits","attribute","SUI_DEVNET_CHAIN","SUI_TESTNET_CHAIN","SUI_LOCALNET_CHAIN","SUI_MAINNET_CHAIN","SUI_CHAINS","_ReadonlyWalletAccount_address","_ReadonlyWalletAccount_publicKey","_ReadonlyWalletAccount_chains","_ReadonlyWalletAccount_features","_ReadonlyWalletAccount_label","_ReadonlyWalletAccount_icon","ReadonlyWalletAccount","account","publicKey","chains","features","icon","EmptyError","mapToPromise","stream","seen","response","_value","_hasValue","API_ENV_TO_CHAIN","accounts","nickname","permissions","network","env","responseForID","createMessage","wallet","register","dispatchEvent","console","api","registerWallet","connect","signAndExecuteTransactionBlock","signMessage","signPersonalMessage","qredoConnect","event","listener","emit","silent","transactionBlock","accountAddress","messageBytes","signature","method","allowed","all","isWalletStatusChangePayload"],"sourceRoot":""}